static char _Test0() {
	{
		{
			{ { { }}}
		}
	}
	return '0';
}

#define C(abcd0_) #abcd0_ abcd0_#abcd0_ abcd0_## abcd0 # abcd0_

#define RESULT_TEST0_TESTA
#define RESULT_TESTA
#define TESTA

struct STR0{
	int t;
};
inline int T1(struct STR0 AB10)
{
	return AB10.t;
}


#ifdef A
#endif

void a(){
	int b=1<<!1;
	b<<=!1;
}

double T() {
	char *str = "Hello\n\x01!\\";
	int a0 = 1<<!0x10;
	a0 <<=+1<<+1<+10;
	do {a0++;} while (a0<10);
	int b = a0-a0 - 1- 2 -3;
	int*x;
	a0--;
	return 0;
}

//0123456789


static double Test(int input) {
	static const int  x;
	float* number;
	const char * str = "Hello\n01234\\";
	char tick = 'a';
	int output = input;
	int vala = output*output+2;
	int valb = 10 / 2;
	if (vala-->=0)
		vala>>=vala;
	return output;
}

/*
 * Test
 */

#define HELLO { \
	int o = 1; \
	int i = 0; /* Test */ \
}

/*
	rayDE - Raylib Development Enviornment

+---------------------------+------------------------------------------------+
| Shortcut                  | Action                                         |
+---------------------------+------------------------------------------------+
| FILE OPERATIONS                                                            |
+---------------------------+------------------------------------------------+
| Ctrl+N                    | New file                                       |
| Ctrl+O                    | Open file                                      |
| Ctrl+S                    | Save                                           |
| Ctrl+Shift+S              | Save As                                        |
| Ctrl+W                    | Close current tab/file                         |
+---------------------------+------------------------------------------------+
| BASIC EDITING                                                              |
+---------------------------+------------------------------------------------+
| Ctrl+Z                    | Undo                                           |
| Ctrl+Y (or Ctrl+Shift+Z)  | Redo                                           |
| Ctrl+A                    | Select all                                     |
| Ctrl+L                    | Select entire current line                     |
| Ctrl+R                    | Delete character                               |
| Ctrl+Shift+R              | Delete line                                    |
| Ctrl+D                    | Duplikinde line below                           |
| Ctrl+Shift+D              | Duplikinde line above                           |
| Ctrl+Enter                | Insert line below without moving cursor        |
| Ctrl+Shift+Enter          | Insert line above                              |
| Tab                       | Indent                                         |
| Shift+Tab                 | Unindent                                       |
| Ctrl+/                    | Toggle line comment                            |
+---------------------------+------------------------------------------------+
| NAVIGATION                                                                 |
+---------------------------+------------------------------------------------+
| Home                      | Go to beginning of line                        |
| End                       | Go to end of line                              |
| Ctrl+Home                 | Go to beginning of document                    |
| Ctrl+End                  | Go to end of document                          |
| Ctrl+Left/Right           | Word jump                                      |
| Ctrl+Alt+J/L              | Word jump                                      |
| Ctrl+Up/Down              | Block jump                                     |
| Ctrl+Alt+I/K              | Block jump                                     |
| Up/Down/Left/Right        | Move                                           |
| Alt+I/J/K/L               | Move Alt                                       |
| Ctrl+G                    | Go to line number                              |
| Ctrl+M                    | Go to matching bracket                         |
| Alt Toggle                | Command Mode                                   |
+---------------------------+------------------------------------------------+
| SELECTION                                                                  |
+---------------------------+------------------------------------------------+
| Shift+Left/Right          | Select character                               |
| Shift+Up/Down             | Select line up/down                            |
| Shift+Home                | Select to beginning of line                    |
| Shift+End                 | Select to end of line                          |
| Ctrl+Shift+Left/Right     | Select word jump                               |
| Ctrl+Shift+Alt+J/L        | Select word jump                               |
| Ctrl+Shift+Up/Down        | Block select / Multi-cursor                    |
| Ctrl+Shift+Alt+I/K        | Block select / Multi-cursor                    |
| Ctrl+Shift+Mouse Drag     | Block select                                   |
| Mouse Double Click        | Select word                                    |
| Mouse Triple Click        | Select line                                    |
+---------------------------+------------------------------------------------+
| MULTI-CURSOR & FIND/REPLACE                                                |
+---------------------------+------------------------------------------------+
| Ctrl+Shift+N              | Select next occurrence (multi-cursor)          |
| Ctrl+Shift+B              | Select previous occurrence                     |
// I think this should be command?
// I need command drawer you can click on
| Ctrl+F                    | Find                                           |
| Ctrl+H                    | Find and replace                               |
| F3                        | Find next                                      |
| Shift+F3                  | Find previous                                  |
+---------------------------+------------------------------------------------+
| MOVEMENT                                                                   |
+---------------------------+------------------------------------------------+
| Ctrl+E                    | Expand selection (to word, to scope)           |
| Ctrl+Shift+E              | Shrink selection                               |
| Alt+Shift+Up/Down         | Move line up/down                              |
| Alt+Shift+Left/Right      | Move selection left/right                      |
+---------------------------+------------------------------------------------+
| CODE ASSISTANCE                                                            |
+---------------------------+------------------------------------------------+
| Ctrl+Space                | Autocomplete menu                              |
| Ctrl+Shift+Space          | Parameter info                                 |
+---------------------------+------------------------------------------------+
| TEXT WRAPPING                                                              |
+---------------------------+------------------------------------------------+
| Ctrl+Shift+{ }            | Wrap with braces                               |
| Ctrl+[ ]                  | Wrap with brackets                             |
| Ctrl+Shift+( )            | Wrap with parentheses                          |
| Ctrl+'                    | Wrap with single quotes                        |
| Ctrl+Shift+"              | Wrap with double quotes                        |
| Ctrl+`                    | Wrap with backticks                            |
+---------------------------+------------------------------------------------+
| WORD OPERATIONS                                                            |
+---------------------------+------------------------------------------------+
| Ctrl+Backspace            | Delete word backwards                          |
| Ctrl+Delete               | Delete word forwards                           |
+---------------------------+------------------------------------------------+

GOOD IDEA
Alt + { - Jump to Nearest, then next
Alt + } - ...
Alt + [ - ...
Alt + ] - ...
Alt + " - ...

*/

#include <stdio.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <assert.h>
#include <limits.h>

#include "raylib.h"
#include "raymath.h"

/*
 * Logging
 */
#define ANSI_RESET   "\033[0m"
#define ANSI_BLACK   "\033[30m"
#define ANSI_RED     "\033[31m"
#define ANSI_GREEN   "\033[32m"
#define ANSI_YELLOW  "\033[33m"
#define ANSI_BLUE    "\033[34m"
#define ANSI_MAGENTA "\033[35m"
#define ANSI_CYAN    "\033[36m"
#define ANSI_WHITE   "\033[37m"

#define ANSI_BRIGHT_BLACK   "\033[90m"
#define ANSI_BRIGHT_RED     "\033[91m"
#define ANSI_BRIGHT_GREEN   "\033[92m"
#define ANSI_BRIGHT_YELLOW  "\033[93m"
#define ANSI_BRIGHT_BLUE    "\033[94m"
#define ANSI_BRIGHT_MAGENTA "\033[95m"
#define ANSI_BRIGHT_CYAN    "\033[96m"
#define ANSI_BRIGHT_WHITE   "\033[97m"

#define ANSI_BG_BLACK   "\033[40m"
#define ANSI_BG_RED     "\033[41m"
#define ANSI_BG_GREEN   "\033[42m"
#define ANSI_BG_YELLOW  "\033[43m"
#define ANSI_BG_BLUE    "\033[44m"
#define ANSI_BG_MAGENTA "\033[45m"
#define ANSI_BG_CYAN    "\033[46m"
#define ANSI_BG_WHITE   "\033[47m"

#define ANSI_BG_BRIGHT_BLACK   "\033[100m"
#define ANSI_BG_BRIGHT_RED     "\033[101m"
#define ANSI_BG_BRIGHT_GREEN   "\033[102m"
#define ANSI_BG_BRIGHT_YELLOW  "\033[103m"
#define ANSI_BG_BRIGHT_BLUE    "\033[104m"
#define ANSI_BG_BRIGHT_MAGENTA "\033[105m"
#define ANSI_BG_BRIGHT_CYAN    "\033[106m"
#define ANSI_BG_BRIGHT_WHITE   "\033[107m"

#define ANSI_BOLD      "\033[1m"
#define ANSI_DIM       "\033[2m"
#define ANSI_ITALIC    "\033[3m"
#define ANSI_UNDERLINE "\033[4m"
#define ANSI_REVERSE   "\033[7m"
#define ANSI_HIDDEN    "\033[8m"
#define ANSI_STRIKE    "\033[9m"

#define LOG(_format, ...)      fprintf(stderr, ANSI_DIM ANSI_CYAN __FILE__ ANSI_WHITE ":" ANSI_GREEN "%-5d" ANSI_WHITE  "INFO: " ANSI_RESET _format, __LINE__, ##__VA_ARGS__)
#define LOG_WARN(_format, ...) fprintf(stderr, ANSI_DIM ANSI_BLUE __FILE__ ANSI_WHITE ":" ANSI_GREEN "%-5d" ANSI_YELLOW "WARN: " ANSI_RESET _format, __LINE__, ##__VA_ARGS__)
#define LOG_ERR(_format, ...)  fprintf(stderr, ANSI_DIM ANSI_BLUE __FILE__ ANSI_WHITE ":" ANSI_GREEN "%-5d" ANSI_RED    "ERR:  " ANSI_RESET _format, __LINE__, ##__VA_ARGS__)

/* Log One-Time. Only use in debug it is heavy. */
static char _logOnceBuffer[128];
static char _logOnceNewBuffer[128];
#define DEBUG_LOG_ONCE(_format, ...) ({\
	sprintf(_logOnceNewBuffer, _format, ##__VA_ARGS__);\
	if (strcmp(_logOnceBuffer, _logOnceNewBuffer) != 0) {\
		strcpy(_logOnceBuffer, _logOnceNewBuffer);\
		LOG(_format, __VA_ARGS__);\
	} \
})

#define STATIC_ASSERT(...) _Static_assert(__VA_ARGS__)

static const char* string_CHAR(char c) {
	switch (c) {
		case '\x00': return "\\0NUL";
		case '\x01': return "\\x01SOH";
		case '\x02': return "\\x02STX";
		case '\x03': return "\\x03ETX";
		case '\x04': return "\\x04EOT";
		case '\x05': return "\\x05ENQ";
		case '\x06': return "\\x06ACK";
		case '\x07': return "\\aBEL";
		case '\x08': return "\\bBS";
		case '\x09': return "\\tTAB";
		case '\x0A': return "\\nLF";
		case '\x0B': return "\\vVT";
		case '\x0C': return "\\fFF";
		case '\x0D': return "\\rCR";
		case '\x0E': return "\\x0ESO";
		case '\x0F': return "\\x0FSI";
		case '\x10': return "\\x10DLE";
		case '\x11': return "\\x11DC1";
		case '\x12': return "\\x12DC2";
		case '\x13': return "\\x13DC3";
		case '\x14': return "\\x14DC4";
		case '\x15': return "\\x15NAK";
		case '\x16': return "\\x16SYN";
		case '\x17': return "\\x17ETB";
		case '\x18': return "\\x18CAN";
		case '\x19': return "\\x19EM";
		case '\x1A': return "\\x1ASUB";
		case '\x1B': return "\\x1BESC";
		case '\x1C': return "\\x1CFS";
		case '\x1D': return "\\x1DGS";
		case '\x1E': return "\\x1ERS";
		case '\x1F': return "\\x1FUS";
		case '\\':   return "\\\\";
		case '\'':   return "\\'";
		case '\"':   return "\\\"";
		case '\x7F': return "\\x7FDEL";
		default: {
			static char buf[2] = { '\0', '\0' };
			buf[0] = c;
			return buf;
		}
	}
}

/*
 * Utility
 */
typedef uint8_t       u8;
typedef uint16_t      u16;
typedef uint32_t      u32;
typedef uint64_t      u64;
typedef int8_t        i8;
typedef int16_t       i16;
typedef int32_t       i32;
typedef int64_t       i64;
typedef float         f32;
typedef double        f64;
typedef unsigned char utf8;

#define CACHE_LINE 64

#define MIN(_a, _b)\
({\
	typeof(_a) _valA = (_a);\
	typeof(_b) _valB = (_b);\
	_valA < _valB ? _valA : _valB;\
})

#define MAX(_a, _b)\
({\
	typeof(_a) _valA = (_a);\
	typeof(_b) _valB = (_b);\
	_valA > _valB ? _valA : _valB;\
})

#define ABS(_a)\
({\
	typeof(_a) _valA = (_a);\
	_valA > 0 ? _valA : -_valA;\
})


#define FILL(_arr, _value, _count)\
	for (typeof(_count) i = 0; i < (_count); ++i) { (_arr)[i] = (_value); }

#define UNUSED            __attribute__((unused))
#define FALLTHROUGH       __attribute__((fallthrough));
#define CACHE_ALIGN       __attribute__((aligned(CACHE_LINE)))
#define FORCE_INLINE      __attribute__((always_inline)) static inline
#define PACKED            __attribute__((packed))
#define ALIGN(_size)      __attribute__((aligned(_size)))
#define NO_RETURN         __attribute__((noreturn))

#define LIKELY(x)         __builtin_expect(!!(x), 1)
#define UNLIKELY(x)       __builtin_expect(!!(x), 0)

#define NBYTES(_v)     (sizeof(_v))
#define NBITS(_v)      (sizeof(_v) * CHAR_BIT)
#define NARRAY(_array) (sizeof((_array)) / sizeof((_array)[0]))

#define UMAX(_t) (1 << NBITS(_t))
#define UMIN(_t) ((_t)0)
#define SMAX(_t) ((1 << (NBITS(_t)-1)) - 1)
#define SMIN(_t) (-(1 << (NBITS(_t)-1)))
STATIC_ASSERT(UMAX(u8) == 256);
STATIC_ASSERT(UMIN(u8) == 0);
STATIC_ASSERT(SMAX(i8) == 127);
STATIC_ASSERT(SMIN(i8) == -128);

#define XMALLOC_ALIGNED(_align, _size)\
({\
	void* _p = _aligned_malloc(_size, _align);\
	if (UNLIKELY(_p == NULL)) PANIC("XMALLOC_ALIGNED FAIL!");\
	_p;\
})

#define XCALLOC(_count, _type)\
({\
	void* _p = calloc(_count, sizeof(_type));\
	if (UNLIKELY(_p == NULL)) PANIC("XCALLOC FAIL!");\
	_p;\
})

#define ZERO(_p)             memset((_p), 0, sizeof(*_p))
#define ZERO_RANGE(_p, _len) memset((_p), 0, sizeof((_p)[0]) * (_len))

/*
 * Validation
 */
#ifdef NDEBUG
	#define ASSERT(_condition)
	#define ASSERTMSG(_condition, _format, ...)
#else
	#define ASSERT(_condition)\
		if (UNLIKELY(!(_condition))) {\
			fprintf(stderr, "\n" ANSI_RED __FILE__ ":%d ASSERTMSG! " #_condition " \n" ANSI_RESET, __LINE__);\
			assert((_condition) && #_condition);\
		}

	#define ASSERTMSG(_condition, _format, ...)\
		if (UNLIKELY(!(_condition))) {\
			fprintf(stderr, "\n" ANSI_RED __FILE__ ":%d ASSERTMSG! " #_condition " " _format "\n" ANSI_RESET, __LINE__, ##__VA_ARGS__);\
			assert((_condition) && #_condition);\
		}
#endif

#define PANIC(_format, ...)\
({\
	fprintf(stderr, "\n" ANSI_RED __FILE__ ":%d PANIC! " _format "\n" ANSI_RESET, __LINE__, ##__VA_ARGS__); \
	__builtin_trap();\
})

/* Check will goto RESULT_ERROR label on fail. */
#define CHECK(_condition, _errorResult)\
	if (UNLIKELY(!(_condition))) {\
		fprintf(stderr, "\n" ANSI_YELLOW __FILE__ ":%d TRY! " #_condition " == false! %s\n" ANSI_RESET, __LINE__, string_RESULT(_errorResult));\
		goto _errorResult;\
	}

/* Check will goto RESULT_ERROR label on fail. */
#define CHECKMSG(_condition, _errorResult, _format, ...)\
	if (UNLIKELY(!(_condition))) {\
		fprintf(stderr, "\n" ANSI_YELLOW __FILE__ ":%d TRY! " #_condition " == false! %s " _format "\n" ANSI_RESET, __LINE__, string_RESULT(_errorResult), ##__VA_ARGS__);\
		goto _errorResult;\
	}

#define MUST(_condition)\
	if (UNLIKELY(!(_condition))) {\
		fprintf(stderr, "\n" ANSI_RED __FILE__ ":%d MUST! " #_condition " == false!\n" ANSI_RESET, __LINE__);\
		__builtin_trap();\
	}

/* Require will PANIC on fail. */
#define REQUIRE(_command)\
({\
	RESULT _result = (_command);\
	if (UNLIKELY(_result != RESULT_SUCCESS)) PANIC(#_command " == %s\n", string_RESULT(_result));\
})

/*
 * Global Enum
 */
#define DEF_ARRAY_ITEM(_item, ...)  _item,
#define DEF_ENUM_ITEM(_item, ...)   _item __VA_OPT__(=) __VA_ARGS__,
#define DEF_STRING_ITEM(_item, ...) case _item: return #_item;
#define DEF_ENUM(_enum)\
	typedef enum PACKED _enum {\
		DEF_##_enum(DEF_ENUM_ITEM)\
	} _enum; \
	static const char* string_##_enum(_enum _item) {\
		switch(_item) {\
			DEF_##_enum(DEF_STRING_ITEM)\
			default: return #_enum " N/A";\
		}\
	}

#define DEF_RESULT(DEF)\
	DEF(RESULT_ORDER_ERROR,     -7)\
	DEF(RESULT_CAPACITY_ERROR,  -6)\
	DEF(RESULT_DUPLICATE_ERROR, -5)\
	DEF(RESULT_OFFSET_ERROR,    -4)\
	DEF(RESULT_PARSE_ERROR,     -3)\
	DEF(RESULT_COLLISION_ERROR, -2)\
	DEF(RESULT_ERROR,           -1)\
	DEF(RESULT_SUCCESS,          0)
DEF_ENUM(RESULT);

#define DEF_DIRECTION(DEF)\
	DEF(DIRECTION_NONE)\
	DEF(DIRECTION_FORWARD)\
	DEF(DIRECTION_BACKWARD)\
	DEF(DIRECTION_COUNT)
DEF_ENUM(DIRECTION);

#define DEF_SCOPE(DEF)\
	DEF(SCOPE_TAB)\
	DEF(SCOPE_DEFINE)\
	DEF(SCOPE_CURLY)\
	DEF(SCOPE_PAREN)\
	DEF(SCOPE_BRACKET)\
	DEF(SCOPE_QUOTE)\
	DEF(SCOPE_BLOCK_COMMENT)\
	DEF(SCOPE_LINE_COMMENT)\
	DEF(SCOPE_COUNT)
DEF_ENUM(SCOPE);

/*
 * Coddebox Color Scheme
 */
#define DEFINE_SCHEME_BORING

#define FIND_CARET_COLOR  (Color){   0, 255,   0, 255 }
#define FIND_COLOR_COLOR  (Color){   0, 255,   0, 64  }
#define COLOR_COMMAND_BOX (Color){  20,  20,   2, 200 }
#define COLOR_TEXT_BOX    (Color){  37,  37,  38, 255 }
#define COLOR_NONE        (Color){   0,   0,   0, 255 }
#define COLOR_CLEAR (Color){ 0, 0, 0, 0 }

#define LERP(_a, _b, _t) (((_b - _a) * _t) + _a)
#define COLOR_A(_color, _a) (Color){ _color.r, _color.g, _color.b, _a }

#define DIM_RATIO        0.9f
#define BRIGHT_RATIO     0.1f
#define ALPHA_HIGHLIGHT  48

#ifdef DEFINE_SCHEME_BORING
#define DEF_SCHEME(DEF)\
	DEF(COLOR_CARET,      240, 180,  88)  /* #f0b458 */\
	DEF(COLOR_HOVER,      153, 199, 148)  /* #99c794 */\
	DEF(COLOR_BACKGROUND,  48,  56,  65)  /* #303841 */\
	DEF(COLOR_IDENTIFIER, 216, 222, 233)  /* #d8dee9 */\
	DEF(COLOR_ERROR,      232,  96,  96)  /* #e86060 */\
	DEF(COLOR_PREPROCESS, 135, 132, 219)  /* #8784db */\
	DEF(COLOR_CONTINUE,   148,  99, 148)  /* #946394 */\
	DEF(COLOR_NUMBER,     249, 174,  87)  /* #f9ae57 */\
	DEF(COLOR_STRING,     153, 199, 148)  /* #99c794 */\
	DEF(COLOR_COMMENT,    166, 172, 185)  /* #a6acb9 */\
	DEF(COLOR_OPERATOR,   200, 160, 140)  /* #c8a08c */\
	DEF(COLOR_ESCAPE,     198, 149, 198)  /* #c695c6 */\
	DEF(COLOR_QUOTE,       96, 180, 180)  /* #60b4b4 */\
	DEF(COLOR_SCOPE,      184, 164, 132)  /* #b8a484 */\
	DEF(COLOR_KEYWORD,    236,  96, 102)  /* #ec6066 */\
	DEF(COLOR_TYPE,       198, 149, 198)  /* #c695c6 */
#endif

#ifdef DEFINE_SCHEME_PERCEPTUA
#define DEF_SCHEME(DEF)\
	DEF(COLOR_CARET,      230, 180, 100)  /* #e6b464 */\
	DEF(COLOR_HOVER,      122, 162, 247)  /* #7aa2f7 */\
	DEF(COLOR_BACKGROUND,  26,  27,  38)  /* #1a1b26 */\
	DEF(COLOR_IDENTIFIER, 176, 184, 220)  /* #b0b8dc */\
	DEF(COLOR_ERROR,      247, 118, 142)  /* #f7768e */\
	DEF(COLOR_PREPROCESS, 192, 202, 245)  /* #c0caf5 */\
	DEF(COLOR_CONTINUE,   192, 160, 245)  /* #c0a0f5 */\
	DEF(COLOR_NUMBER,     192, 160, 245)  /* #c0a0f5 */\
	DEF(COLOR_STRING,     166, 212, 112)  /* #a6d470 */\
	DEF(COLOR_COMMENT,     99, 109, 166)  /* #636da6 */\
	DEF(COLOR_OPERATOR,   192, 180, 160)  /* #c0b4a0 */\
	DEF(COLOR_ESCAPE,     255, 168, 100)  /* #ffa864 */\
	DEF(COLOR_QUOTE,      137, 221, 255)  /* #89ddff */\
	DEF(COLOR_SCOPE,      208, 184, 140)  /* #d0b88c */\
	DEF(COLOR_KEYWORD,    132, 172, 250)  /* #84acfa */\
	DEF(COLOR_TYPE,        60, 200, 220)  /* #3cc8dc */
#endif

#ifdef DEFINE_SCHEME_PERCEPTUA_SOLARIZED
#define DEF_SCHEME(DEF)\
	DEF(COLOR_CARET,      240, 208, 140)  /* #f0d08c */\
	DEF(COLOR_HOVER,      172, 200, 148)  /* #acc894 */\
	DEF(COLOR_BACKGROUND,  40,  44,  52)  /* #282c34 */\
	DEF(COLOR_IDENTIFIER, 220, 226, 236)  /* #dce2ec */\
	DEF(COLOR_ERROR,      200, 108, 108)  /* #c86c6c */\
	DEF(COLOR_PREPROCESS, 188, 148, 180)  /* #bc94b4 */\
	DEF(COLOR_NUMBER,     216, 144, 116)  /* #d89074 */\
	DEF(COLOR_STRING,     172, 200, 148)  /* #acc894 */\
	DEF(COLOR_COMMENT,    107, 112, 127)  /* #6b707f */\
	DEF(COLOR_OPERATOR,   192, 176, 156)  /* #c0b09c */\
	DEF(COLOR_ESCAPE,     240, 208, 140)  /* #f0d08c */\
	DEF(COLOR_SCOPE,      176, 192, 168)  /* #b0c0a8 */\
	DEF(COLOR_KEYWORD,    240, 208, 140)  /* #f0d08c */\
	DEF(COLOR_TYPE,       152, 196, 196)  /* #98c4c4 */
#endif

#ifdef DEFINE_SCHEME_PATINA
#define DEF_SCHEME(DEF)\
	DEF(COLOR_CARET,      224, 172,  84)  /* #e0ac54 */\
	DEF(COLOR_HOVER,      172, 196, 124)  /* #acc47c */\
	DEF(COLOR_BACKGROUND,  26,  24,  21)  /* #1a1815 */\
	DEF(COLOR_IDENTIFIER, 220, 208, 188)  /* #dcd0bc */\
	DEF(COLOR_ERROR,      200, 120, 100)  /* #c87864 */\
	DEF(COLOR_PREPROCESS, 208, 168, 132)  /* #d0a884 */\
	DEF(COLOR_NUMBER,     212, 188,  96)  /* #d4bc60 */\
	DEF(COLOR_STRING,     172, 196, 124)  /* #acc47c */\
	DEF(COLOR_COMMENT,    116, 106,  92)  /* #746a5c */\
	DEF(COLOR_OPERATOR,   188, 168, 136)  /* #bca888 */\
	DEF(COLOR_ESCAPE,     232, 200, 100)  /* #e8c864 */\
	DEF(COLOR_QUOTE,      172, 196, 124)  /* #acc47c */\
	DEF(COLOR_SCOPE,      176, 176, 140)  /* #b0b08c */\
	DEF(COLOR_KEYWORD,    224, 172,  84)  /* #e0ac54 */\
	DEF(COLOR_TYPE,       152, 196, 148)  /* #98c494 */
#endif

#ifdef DEFINE_SCHEME_GLADE
#define DEF_SCHEME(DEF)\
	DEF(COLOR_CARET,      248, 200,  80)  /* #f8c850 */\
	DEF(COLOR_HOVER,      148, 208, 108)  /* #94d06c */\
	DEF(COLOR_BACKGROUND,  38,  40,  42)  /* #26282a */\
	DEF(COLOR_IDENTIFIER, 236, 238, 232)  /* #eceee8 */\
	DEF(COLOR_ERROR,      224, 104, 104)  /* #e06868 */\
	DEF(COLOR_PREPROCESS, 208, 168, 124)  /* #d0a87c */\
	DEF(COLOR_NUMBER,     248, 200,  80)  /* #f8c850 */\
	DEF(COLOR_STRING,     148, 208, 108)  /* #94d06c */\
	DEF(COLOR_COMMENT,    128, 132, 136)  /* #808488 */\
	DEF(COLOR_OPERATOR,   176, 180, 160)  /* #b0b4a0 */\
	DEF(COLOR_ESCAPE,     248, 200,  80)  /* #f8c850 */\
	DEF(COLOR_QUOTE,      148, 208, 108)  /* #94d06c */\
	DEF(COLOR_SCOPE,      188, 176, 136)  /* #bcb088 */\
	DEF(COLOR_KEYWORD,    104, 188, 208)  /* #68bcd0 */\
	DEF(COLOR_TYPE,       112, 200, 168)  /* #70c8a8 */
#endif

#define DEF_COLOR(_name, _r, _g, _b)\
	static const Color _name##_HIGHLIGHT = { LERP( 0, _r,     DIM_RATIO), LERP( 0,  _g,    DIM_RATIO), LERP( 0,  _b,    DIM_RATIO), ALPHA_HIGHLIGHT };\
	static const Color _name##_BRIGHT    = { LERP(_r, 255, BRIGHT_RATIO), LERP(_g, 255, BRIGHT_RATIO), LERP(_b, 255, BRIGHT_RATIO), 255 };\
	static const Color _name##_DIM       = { LERP( 0, _r,     DIM_RATIO), LERP( 0,  _g,    DIM_RATIO), LERP( 0,  _b,    DIM_RATIO), 255 };\
    static const Color _name             = { _r, _g, _b, 255 };

DEF_SCHEME(DEF_COLOR)

#undef DEF_COLOR

/*
 * Lex Token Constants
 */
#define TOK_CAPACITY 256

#define TOK_SPECIAL_BEGIN 0
#define TOK_SPECIAL_END   7
#define TOK_SPECIAL_RANGE TOK_SPECIAL_BEGIN ... TOK_SPECIAL_END

#define TOK_WHITE_BEGIN 9
#define TOK_WHITE_END   13
#define TOK_WHITE_RANGE TOK_WHITE_BEGIN ... TOK_WHITE_END

#define TOK_LOWER_ALPHA_BEGIN 'a'
#define TOK_LOWER_ALPHA_END   'z'
#define TOK_LOWER_ALPHA_RANGE TOK_LOWER_ALPHA_BEGIN ... TOK_LOWER_ALPHA_END

#define TOK_UPPER_ALPHA_BEGIN 'A'
#define TOK_UPPER_ALPHA_END   'Z'
#define TOK_UPPER_ALPHA_RANGE TOK_UPPER_ALPHA_BEGIN ... TOK_UPPER_ALPHA_END

#define TOK_DIGIT_BEGIN '0'
#define TOK_DIGIT_END   '9'
#define TOK_DIGIT_RANGE TOK_DIGIT_BEGIN ... TOK_DIGIT_END

#define TOK_ASCII_BEGIN 32  /* ' ' */
#define TOK_ASCII_END   127 /* '~' */
#define TOK_ASCII_RANGE TOK_ASCII_BEGIN ... TOK_ASCII_END

#define TOK_KEYWORD_BEGIN 128
#define TOK_KEYWORD_END   255
#define TOK_KEYWORD_RANGE TOK_KEYWORD_BEGIN ... TOK_KEYWORD_END

#define TOK_ALL_BEGIN 0
#define TOK_ALL_END   255
#define TOK_ALL_RANGE TOK_ALL_BEGIN ... TOK_ALL_END

#define TOK_RANGE_NAME "\005"
#define TOK_DELIM_STR  "\003"

#define IS_DELIM_TOKEN(_c)   (_c == TOK_DELIMIT)
#define IS_SPECIAL_TOKEN(_c) (_c <= TOK_FRIE_SECIAL_END)
#define IS_KEYWORD_TOKEN(_c) (_c >= TOK_KEYWORD_BEGIN)
#define IS_KEYWORD_OR_SPECIAL_TOKEN(_c) (((i8)_c) <= TOK_SPECIAL_END)

static const bool IDENT_CHAR[128] = {
	['a'...'z'] = 1,
	['A'...'Z'] = 1,
	['0'...'9'] = 1,
	['_'] = 1,
};

#define IS_IDENT_CHAR(_c) IDENT_CHAR[(u8)(_c)]
#define IS_DELIM_CHAR(_c) !IDENT_CHAR[(u8)(_c)]

#define IS_DIGIT_CHAR(_c) (CHAR_FLAGS[(u8)(_c)] & CHAR_DIGIT)
#define IS_SPACE_CHAR(_c) (CHAR_FLAGS[(u8)(_c)] & CHAR_SPACE)

/*
 * Lex Token Definition
 */
#define DEF_TOK_KIND(DEF)\
	DEF(TOK_KIND_NONE)\
	DEF(TOK_KIND_WHITESPACE)\
	DEF(TOK_KIND_ERROR)\
	DEF(TOK_KIND_ALPHA)\
	DEF(TOK_KIND_DIGIT)\
	DEF(TOK_KIND_ASSIGN)\
	DEF(TOK_KIND_NUMBER)\
	DEF(TOK_KIND_IDENTIFIER)\
	DEF(TOK_KIND_TYPE)\
	DEF(TOK_KIND_KEYWORD)\
	DEF(TOK_KIND_OPERATOR)\
	DEF(TOK_KIND_STATEMENT)\
	DEF(TOK_KIND_PP)\
	DEF(TOK_KIND_CONTINUE)\
	DEF(TOK_KIND_SCOPE)\
	DEF(TOK_KIND_SCOPE_FADE)\
	DEF(TOK_KIND_QUOTE)\
	DEF(TOK_KIND_STRING)\
	DEF(TOK_KIND_ESCAPE)\
	DEF(TOK_KIND_COMMENT)\
	DEF(TOK_KIND_COUNT)
DEF_ENUM(TOK_KIND);

static const Color TOK_KIND_COLOR[] = {
	[TOK_KIND_NONE]        = COLOR_NONE,
	[TOK_KIND_ERROR]       = COLOR_ERROR,
	[TOK_KIND_ALPHA]       = COLOR_ERROR,
	[TOK_KIND_DIGIT]       = COLOR_ERROR,
	[TOK_KIND_TYPE]        = COLOR_TYPE,
	[TOK_KIND_NUMBER]      = COLOR_NUMBER,
	[TOK_KIND_IDENTIFIER]  = COLOR_IDENTIFIER,
	[TOK_KIND_KEYWORD]     = COLOR_KEYWORD,
	[TOK_KIND_WHITESPACE]  = COLOR_BACKGROUND_BRIGHT,
	[TOK_KIND_STATEMENT]   = COLOR_OPERATOR,
	[TOK_KIND_ASSIGN]      = COLOR_OPERATOR,
	[TOK_KIND_OPERATOR]    = COLOR_OPERATOR,
	[TOK_KIND_PP]          = COLOR_PREPROCESS,
	[TOK_KIND_SCOPE]       = COLOR_SCOPE,
	[TOK_KIND_SCOPE_FADE]  = COLOR_TYPE_DIM,
	[TOK_KIND_QUOTE]       = COLOR_QUOTE,
	[TOK_KIND_STRING]      = COLOR_STRING,
	[TOK_KIND_ESCAPE]      = COLOR_ESCAPE,
	[TOK_KIND_COMMENT]     = COLOR_COMMENT,
};
STATIC_ASSERT(NARRAY(TOK_KIND_COLOR) == TOK_KIND_COUNT);

static const Color TOK_KIND_HIGHLIGHT_COLOR[] = {
	[TOK_KIND_NONE]        = COLOR_NONE,
	[TOK_KIND_ERROR]       = COLOR_ERROR_HIGHLIGHT,
	[TOK_KIND_ALPHA]       = COLOR_ERROR_HIGHLIGHT,
	[TOK_KIND_DIGIT]       = COLOR_ERROR_HIGHLIGHT,
	[TOK_KIND_TYPE]        = COLOR_TYPE_HIGHLIGHT,
	[TOK_KIND_NUMBER]      = COLOR_NUMBER_HIGHLIGHT,
	[TOK_KIND_IDENTIFIER]  = COLOR_IDENTIFIER_HIGHLIGHT,
	[TOK_KIND_KEYWORD]     = COLOR_KEYWORD_HIGHLIGHT,
	[TOK_KIND_WHITESPACE]  = COLOR_BACKGROUND_HIGHLIGHT,
	[TOK_KIND_STATEMENT]   = COLOR_OPERATOR_HIGHLIGHT,
	[TOK_KIND_ASSIGN]      = COLOR_OPERATOR_HIGHLIGHT,
	[TOK_KIND_OPERATOR]    = COLOR_OPERATOR_HIGHLIGHT,
	[TOK_KIND_PP]          = COLOR_PREPROCESS_HIGHLIGHT,
	[TOK_KIND_SCOPE]       = COLOR_SCOPE_HIGHLIGHT,
	[TOK_KIND_SCOPE_FADE]  = COLOR_TYPE_HIGHLIGHT,
	[TOK_KIND_QUOTE]       = COLOR_QUOTE_HIGHLIGHT,
	[TOK_KIND_STRING]      = COLOR_CLEAR,
	[TOK_KIND_ESCAPE]      = COLOR_ESCAPE_HIGHLIGHT,
	[TOK_KIND_COMMENT]     = COLOR_CLEAR,
};
STATIC_ASSERT(NARRAY(TOK_KIND_HIGHLIGHT_COLOR) == TOK_KIND_COUNT);


static const Color TOK_SCOPE_COLORS[] = {
	COLOR_PREPROCESS_DIM,
	COLOR_SCOPE_DIM,
	COLOR_OPERATOR_DIM,
	COLOR_ESCAPE_DIM,
	COLOR_QUOTE_DIM,
};

#define DEF_TOK(DEF)\
	/* Special */\
	DEF(TOK_NONE,        /*NUL*/'\000')\
	DEF(TOK_SPARSE_CHAR, /*SOH*/'\001')\
	DEF(TOK_PACKED_CHAR, /*STX*/'\002')\
	DEF(TOK_DELIMIT,     /*ETX*/'\003')\
	DEF(TOK_MUNCH,              '\006')\
	DEF(TOK_ERR,         /*ENQ*/'\004')\
	DEF(TOK_RANGE,              '\005')\
	/* White Spaces */\
	DEF(TOK_TAB,          /* 9*/'\t')\
	DEF(TOK_VERTICAL_TAB, /*10*/'\v')\
	DEF(TOK_NEWLINE,      /*10*/'\n')\
	DEF(TOK_FORM_FEED,    /*12*/'\f')\
	DEF(TOK_CARR_RETURN,  /*13*/'\r')\
	/*ASCII 32-126*/\
	DEF(TOK_SPACE,      /*32*/' ' )\
	DEF(TOK_BANG,       /*33*/'!' )\
	DEF(TOK_DQUOTE,     /*34*/'"' )\
	DEF(TOK_HASH,       /*35*/'#' )\
	DEF(TOK_DOLLAR,     /*36*/'$' )\
	DEF(TOK_PERCENT,    /*37*/'%' )\
	DEF(TOK_AMP,        /*38*/'&' )\
	DEF(TOK_SQUOTE,     /*39*/'\'')\
	DEF(TOK_LPAREN,     /*40*/'(' )\
	DEF(TOK_RPAREN,     /*41*/')' )\
	DEF(TOK_STAR,       /*42*/'*' )\
	DEF(TOK_PLUS,       /*43*/'+' )\
	DEF(TOK_COMMA,      /*44*/',' )\
	DEF(TOK_MINUS,      /*45*/'-' )\
	DEF(TOK_DOT,        /*46*/'.' )\
	DEF(TOK_SLASH,      /*47*/'/' )\
	DEF(TOK_0,          /*48*/'0' )\
	DEF(TOK_1,          /*49*/'1' )\
	DEF(TOK_2,          /*50*/'2' )\
	DEF(TOK_3,          /*51*/'3' )\
	DEF(TOK_4,          /*52*/'4' )\
	DEF(TOK_5,          /*53*/'5' )\
	DEF(TOK_6,          /*54*/'6' )\
	DEF(TOK_7,          /*55*/'7' )\
	DEF(TOK_8,          /*56*/'8' )\
	DEF(TOK_9,          /*57*/'9' )\
	DEF(TOK_COLON,      /*58*/':' )\
	DEF(TOK_SEMICOLON,  /*59*/';' )\
	DEF(TOK_LT,         /*60*/'<' )\
	DEF(TOK_EQ,         /*61*/'=' )\
	DEF(TOK_GT,         /*62*/'>' )\
	DEF(TOK_QUESTION,   /*63*/'?' )\
	DEF(TOK_AT,         /*64*/'@' )\
	DEF(TOK_A,          /*65*/'A' )\
	DEF(TOK_B,          /*66*/'B' )\
	DEF(TOK_C,          /*67*/'C' )\
	DEF(TOK_D,          /*68*/'D' )\
	DEF(TOK_E,          /*69*/'E' )\
	DEF(TOK_F,          /*70*/'F' )\
	DEF(TOK_G,          /*71*/'G' )\
	DEF(TOK_H,          /*72*/'H' )\
	DEF(TOK_I,          /*73*/'I' )\
	DEF(TOK_J,          /*74*/'J' )\
	DEF(TOK_K,          /*75*/'K' )\
	DEF(TOK_L,          /*76*/'L' )\
	DEF(TOK_M,          /*77*/'M' )\
	DEF(TOK_N,          /*78*/'N' )\
	DEF(TOK_O,          /*79*/'O' )\
	DEF(TOK_P,          /*80*/'P' )\
	DEF(TOK_Q,          /*81*/'Q' )\
	DEF(TOK_R,          /*82*/'R' )\
	DEF(TOK_S,          /*83*/'S' )\
	DEF(TOK_T,          /*84*/'T' )\
	DEF(TOK_U,          /*85*/'U' )\
	DEF(TOK_V,          /*86*/'V' )\
	DEF(TOK_W,          /*87*/'W' )\
	DEF(TOK_X,          /*88*/'X' )\
	DEF(TOK_Y,          /*89*/'Y' )\
	DEF(TOK_Z,          /*90*/'Z' )\
	DEF(TOK_LBRACKET,   /*91*/'[' )\
	DEF(TOK_BACKSLASH,  /*92*/'\\')\
	DEF(TOK_RBRACKET,   /*93*/']' )\
	DEF(TOK_CARET,      /*94*/'^' )\
	DEF(TOK_UNDERSCORE, /*95*/'_' )\
	DEF(TOK_BACKTICK,   /*96*/'`' )\
	DEF(TOK_a,          /*97*/'a' )\
	DEF(TOK_b,          /*98*/'b' )\
	DEF(TOK_c,          /*99*/'c' )\
	DEF(TOK_d,         /*100*/'d' )\
	DEF(TOK_e,         /*101*/'e' )\
	DEF(TOK_f,         /*102*/'f' )\
	DEF(TOK_g,         /*103*/'g' )\
	DEF(TOK_h,         /*104*/'h' )\
	DEF(TOK_i,         /*105*/'i' )\
	DEF(TOK_j,         /*106*/'j' )\
	DEF(TOK_k,         /*107*/'k' )\
	DEF(TOK_l,         /*108*/'l' )\
	DEF(TOK_m,         /*109*/'m' )\
	DEF(TOK_n,         /*110*/'n' )\
	DEF(TOK_o,         /*111*/'o' )\
	DEF(TOK_p,         /*112*/'p' )\
	DEF(TOK_q,         /*113*/'q' )\
	DEF(TOK_r,         /*114*/'r' )\
	DEF(TOK_s,         /*115*/'s' )\
	DEF(TOK_t,         /*116*/'t' )\
	DEF(TOK_u,         /*117*/'u' )\
	DEF(TOK_v,         /*118*/'v' )\
	DEF(TOK_w,         /*119*/'w' )\
	DEF(TOK_x,         /*120*/'x' )\
	DEF(TOK_y,         /*121*/'y' )\
	DEF(TOK_z,         /*122*/'z' )\
	DEF(TOK_LBRACE,    /*123*/'{' )\
	DEF(TOK_PIPE,      /*124*/'|' )\
	DEF(TOK_RBRACE,    /*125*/'}' )\
	DEF(TOK_TILDE,     /*126*/'~' )\
	/* Keywords 128+ */\
	/* PreProcess */\
	DEF(TOK_PP_INCLUDE, TOK_KEYWORD_BEGIN)\
	DEF(TOK_PP_DEFINE)\
	DEF(TOK_PP_IFNDEF)\
	DEF(TOK_PP_IFDEF)\
	DEF(TOK_PP_ENDIF)\
	DEF(TOK_PP_UNDEF)\
	DEF(TOK_PP_ELIF)\
	DEF(TOK_PP_ELSE)\
	DEF(TOK_PP_ERROR)\
	DEF(TOK_PP_PRAGMA)\
	DEF(TOK_PP_LINE)\
	DEF(TOK_PP_IF)\
	DEF(TOK_HASH_HASH)\
	/* Keyword */\
	DEF(TOK_STATIC_ASSERT)\
	DEF(TOK_THREAD_LOCAL)\
	DEF(TOK_IMAGINARY)\
	DEF(TOK_NORETURN)\
	DEF(TOK_COMPLEX)\
	DEF(TOK_GENERIC)\
	DEF(TOK_ALIGNOF)\
	DEF(TOK_ALIGNAS)\
	DEF(TOK_ATOMIC)\
	DEF(TOK_ATTRIBUTE)\
	DEF(TOK_CONTINUE)\
	DEF(TOK_VOLATILE)\
	DEF(TOK_REGISTER)\
	DEF(TOK_RESTRICT)\
	DEF(TOK_TYPEDEF)\
	DEF(TOK_DEFAULT)\
	DEF(TOK_TYPEOF)\
	DEF(TOK_SWITCH)\
	DEF(TOK_STATIC)\
	DEF(TOK_SIZEOF)\
	DEF(TOK_RETURN)\
	DEF(TOK_INLINE)\
	DEF(TOK_EXTERN)\
	DEF(TOK_WHILE)\
	DEF(TOK_CONST)\
	DEF(TOK_BREAK)\
	DEF(TOK_GOTO)\
	DEF(TOK_ELSE)\
	DEF(TOK_CASE)\
	DEF(TOK_FOR)\
	DEF(TOK_IF)\
	DEF(TOK_DO)\
	/* Type */\
	DEF(TOK_AUTO)\
	DEF(TOK_UNSIGNED)\
	DEF(TOK_STRUCT)\
	DEF(TOK_SIGNED)\
	DEF(TOK_DOUBLE)\
	DEF(TOK_FLOAT)\
	DEF(TOK_SHORT)\
	DEF(TOK_BOOL)\
	DEF(TOK_UNION)\
	DEF(TOK_VOID)\
	DEF(TOK_LONG)\
	DEF(TOK_CHAR)\
	DEF(TOK_ENUM)\
	DEF(TOK_INT)\
	DEF(TOK_PTRDIFF_T)\
	DEF(TOK_UINT64_T)\
	DEF(TOK_UINT32_T)\
	DEF(TOK_UINT16_T)\
	DEF(TOK_INT64_T)\
	DEF(TOK_INT32_T)\
	DEF(TOK_INT16_T)\
	DEF(TOK_WCHAR_T)\
	DEF(TOK_UINT8_T)\
	DEF(TOK_SIZE_T)\
	DEF(TOK_INT8_T)\
	/* Operator */\
	DEF(TOK_INC,           /* ++  */)\
	DEF(TOK_DEC,           /* --  */)\
	DEF(TOK_ARROW,         /* ->  */)\
	DEF(TOK_LSHIFT,        /* <<  */)\
	DEF(TOK_RSHIFT,        /* >>  */)\
	DEF(TOK_LE,            /* <=  */)\
	DEF(TOK_GE,            /* >=  */)\
	DEF(TOK_EQ_EQ,         /* ==  */)\
	DEF(TOK_NE,            /* !=  */)\
	DEF(TOK_AND,           /* &&  */)\
	DEF(TOK_OR,            /* ||  */)\
	DEF(TOK_ADD_ASSIGN,    /* +=  */)\
	DEF(TOK_SUB_ASSIGN,    /* -=  */)\
	DEF(TOK_MUL_ASSIGN,    /* *=  */)\
	DEF(TOK_DIV_ASSIGN,    /* /=  */)\
	DEF(TOK_MASK_ASSIGN,    /* %=  */)\
	DEF(TOK_AND_ASSIGN,    /* &=  */)\
	DEF(TOK_OR_ASSIGN,     /* |=  */)\
	DEF(TOK_XOR_ASSIGN,    /* ^=  */)\
	DEF(TOK_LSHIFT_ASSIGN, /* <<= */)\
	DEF(TOK_RSHIFT_ASSIGN, /* >>= */)\
	DEF(TOK_ELLIPSIS,      /* ... */)\
	/* Comment */\
	DEF(TOK_LBLOCK_COMMENT)\
	DEF(TOK_RBLOCK_COMMENT)\
	DEF(TOK_LINE_COMMENT)\
	/* Escape */\
	DEF(TOK_ESC_NULL,      /* \\0  NUL */)\
	DEF(TOK_ESC_ALERT,     /* \\a  BEL */)\
	DEF(TOK_ESC_BACKSPACE, /* \\b  BS  */)\
	DEF(TOK_ESC_TAB,       /* \\t  TAB */)\
	DEF(TOK_ESC_NEWLINE,   /* \\n  LF  */)\
	DEF(TOK_ESC_VTAB,      /* \\v  VT  */)\
	DEF(TOK_ESC_FORMFEED,  /* \\f  FF  */)\
	DEF(TOK_ESC_RETURN,    /* \\r  CR  */)\
	DEF(TOK_ESC_BACKSLASH, /* \\\\ \\  */)\
	DEF(TOK_ESC_SQUOTE,    /* \\'  '   */)\
	DEF(TOK_ESC_DQUOTE,    /* \\\  "   */)\
	DEF(TOK_ESC_QUESTION,  /* \\?  ?   */)\
	DEF(TOK_ESC_HEX,       /* \\x      */)\
	DEF(TOK_ESC_UNICODE4,  /* \\u      */)\
	DEF(TOK_ESC_UNICODE8,  /* \\U      */)\
	DEF(TOK_ESC_OCTAL,     /* \\U      */)\
	/* Sparse Groups */\
	DEF(TOK_NUMBER)\
	DEF(TOK_NUMBER_BINARY)\
	DEF(TOK_NUMBER_HEX)\
	DEF(TOK_IDENTIFIER)\
	DEF(TOK_STRING)\
	DEF(TOK_COMMENT)\
	DEF(TOK_COUNT)
DEF_ENUM(TOK);
STATIC_ASSERT(TOK_COUNT < TOK_CAPACITY, "Not setup to support more than 256 tokens!");

#define DLM TOK_DELIM_STR

#define DEF_TOK_BASE(DEF, DEF_RANGE)\
	/* Number */\
	DEF("0x"  , TOK_NUMBER_BINARY , TOK_KIND_ESCAPE)\
	DEF("0b"  , TOK_NUMBER_HEX    , TOK_KIND_ESCAPE)\
	/* Brace */\
	DEF("["   , TOK_LBRACKET, TOK_KIND_SCOPE)\
	DEF("]"   , TOK_RBRACKET, TOK_KIND_SCOPE)\
	DEF("{"   , TOK_LBRACE,   TOK_KIND_SCOPE)\
	DEF("}"   , TOK_RBRACE,   TOK_KIND_SCOPE)\
	DEF("("   , TOK_LPAREN,   TOK_KIND_SCOPE)\
	DEF(")"   , TOK_RPAREN,   TOK_KIND_SCOPE)\
	/* Quote */\
	DEF("\""  , TOK_DQUOTE,   TOK_KIND_QUOTE)\
	DEF("\'"  , TOK_SQUOTE,   TOK_KIND_QUOTE)\
	DEF("`"   , TOK_BACKTICK, TOK_KIND_QUOTE)\
	/* Comment */\
	DEF("/*"  , TOK_LBLOCK_COMMENT, TOK_KIND_COMMENT)\
	DEF("//"  , TOK_LINE_COMMENT,  TOK_KIND_COMMENT)\
	/* Operator */\
	DEF("&"   , TOK_AND           , TOK_KIND_OPERATOR)\
	DEF("|"   , TOK_PIPE          , TOK_KIND_OPERATOR)\
	DEF("!"   , TOK_BANG          , TOK_KIND_OPERATOR)\
	DEF("%"   , TOK_PERCENT       , TOK_KIND_OPERATOR)\
	DEF("*"   , TOK_STAR          , TOK_KIND_OPERATOR)\
	DEF("+"   , TOK_PLUS          , TOK_KIND_OPERATOR)\
	DEF(","   , TOK_COMMA         , TOK_KIND_OPERATOR)\
	DEF("-"   , TOK_MINUS         , TOK_KIND_OPERATOR)\
	DEF("."   , TOK_DOT           , TOK_KIND_OPERATOR)\
	DEF("/"   , TOK_SLASH         , TOK_KIND_OPERATOR)\
	DEF("<"   , TOK_LT            , TOK_KIND_OPERATOR)\
	DEF("="   , TOK_EQ            , TOK_KIND_OPERATOR)\
	DEF(">"   , TOK_GT            , TOK_KIND_OPERATOR)\
	DEF("^"   , TOK_CARET         , TOK_KIND_OPERATOR)\
	DEF("~"   , TOK_TILDE         , TOK_KIND_OPERATOR)\
	DEF("++"  , TOK_INC           , TOK_KIND_OPERATOR)\
	DEF("--"  , TOK_DEC           , TOK_KIND_OPERATOR)\
	DEF("->"  , TOK_ARROW         , TOK_KIND_OPERATOR)\
	DEF("<<=" , TOK_LSHIFT_ASSIGN , TOK_KIND_OPERATOR)\
	DEF("<<"  , TOK_LSHIFT        , TOK_KIND_OPERATOR)\
	DEF(">>"  , TOK_RSHIFT        , TOK_KIND_OPERATOR)\
	DEF("<="  , TOK_LE            , TOK_KIND_OPERATOR)\
	DEF(">="  , TOK_GE            , TOK_KIND_OPERATOR)\
	DEF("=="  , TOK_EQ_EQ         , TOK_KIND_OPERATOR)\
	DEF("!="  , TOK_NE            , TOK_KIND_OPERATOR)\
	DEF("&&"  , TOK_AND           , TOK_KIND_OPERATOR)\
	DEF("||"  , TOK_OR            , TOK_KIND_OPERATOR)\
	DEF("+="  , TOK_ADD_ASSIGN    , TOK_KIND_OPERATOR)\
	DEF("-="  , TOK_SUB_ASSIGN    , TOK_KIND_OPERATOR)\
	DEF("*="  , TOK_MUL_ASSIGN    , TOK_KIND_OPERATOR)\
	DEF("/="  , TOK_DIV_ASSIGN    , TOK_KIND_OPERATOR)\
	DEF("%="  , TOK_MASK_ASSIGN    , TOK_KIND_OPERATOR)\
	DEF("&="  , TOK_AND_ASSIGN    , TOK_KIND_OPERATOR)\
	DEF("|="  , TOK_OR_ASSIGN     , TOK_KIND_OPERATOR)\
	DEF("^="  , TOK_XOR_ASSIGN    , TOK_KIND_OPERATOR)\
	DEF(">>=" , TOK_RSHIFT_ASSIGN , TOK_KIND_OPERATOR)\
	/* Statement */\
	DEF("?"   , TOK_QUESTION  , TOK_KIND_STATEMENT)\
	DEF(":"   , TOK_COLON     , TOK_KIND_STATEMENT)\
	DEF("..." , TOK_ELLIPSIS  , TOK_KIND_STATEMENT)\
	DEF(";"   , TOK_SEMICOLON , TOK_KIND_STATEMENT)\
	/* Pre Process */\
	DEF("#"           , TOK_HASH      , TOK_KIND_PP)\
	DEF("##"          , TOK_HASH_HASH , TOK_KIND_PP)\
	DEF("#if"DLM      , TOK_PP_IF     , TOK_KIND_PP)\
	DEF("#elif"DLM    , TOK_PP_ELIF   , TOK_KIND_PP)\
	DEF("#line"DLM    , TOK_PP_LINE   , TOK_KIND_PP)\
	DEF("#else"DLM    , TOK_PP_ELSE   , TOK_KIND_PP)\
	DEF("#error"DLM   , TOK_PP_ERROR  , TOK_KIND_PP)\
	DEF("#undef"DLM   , TOK_PP_UNDEF  , TOK_KIND_PP)\
	DEF("#endif"DLM   , TOK_PP_ENDIF  , TOK_KIND_PP)\
	DEF("#ifdef"DLM   , TOK_PP_IFDEF  , TOK_KIND_PP)\
	DEF("#ifndef"DLM  , TOK_PP_IFNDEF , TOK_KIND_PP)\
	DEF("#pragma"DLM  , TOK_PP_PRAGMA , TOK_KIND_PP)\
	DEF("#define"DLM  , TOK_PP_DEFINE , TOK_KIND_PP)\
	DEF("#include"DLM , TOK_PP_INCLUDE, TOK_KIND_PP)\
	DEF("\\"  /*92*/  , TOK_BACKSLASH , TOK_KIND_PP)\
	/* Specifier */\
	DEF("static"DLM        , TOK_STATIC       , TOK_KIND_KEYWORD)\
	DEF("extern"DLM        , TOK_EXTERN       , TOK_KIND_KEYWORD)\
	DEF("typedef"DLM       , TOK_TYPEDEF      , TOK_KIND_KEYWORD)\
	DEF("register"DLM      , TOK_REGISTER     , TOK_KIND_KEYWORD)\
	DEF("_Thread_local"DLM , TOK_THREAD_LOCAL , TOK_KIND_KEYWORD)\
	/* Qualifier */\
	DEF("const"DLM,    TOK_CONST,    TOK_KIND_KEYWORD)\
	DEF("_Atomic"DLM,  TOK_ATOMIC,   TOK_KIND_KEYWORD)\
	DEF("volatile"DLM, TOK_VOLATILE, TOK_KIND_KEYWORD)\
	DEF("restrict"DLM, TOK_RESTRICT, TOK_KIND_KEYWORD)\
	/* Keyword */\
	DEF("do"DLM,             TOK_DO,            TOK_KIND_KEYWORD)\
	DEF("if"DLM,             TOK_IF,            TOK_KIND_KEYWORD)\
	DEF("for"DLM,            TOK_FOR,           TOK_KIND_KEYWORD)\
	DEF("auto"DLM,           TOK_AUTO,          TOK_KIND_KEYWORD)\
	DEF("case"DLM,           TOK_CASE,          TOK_KIND_KEYWORD)\
	DEF("else"DLM,           TOK_ELSE,          TOK_KIND_KEYWORD)\
	DEF("goto"DLM,           TOK_GOTO,          TOK_KIND_KEYWORD)\
	DEF("break"DLM,          TOK_BREAK,         TOK_KIND_KEYWORD)\
	DEF("while"DLM,          TOK_WHILE,         TOK_KIND_KEYWORD)\
	DEF("typeof"DLM,         TOK_TYPEOF,        TOK_KIND_KEYWORD)\
	DEF("switch"DLM,         TOK_SWITCH,        TOK_KIND_KEYWORD)\
	DEF("inline"DLM,         TOK_INLINE,        TOK_KIND_KEYWORD)\
	DEF("sizeof"DLM,         TOK_SIZEOF,        TOK_KIND_KEYWORD)\
	DEF("return"DLM,         TOK_RETURN,        TOK_KIND_KEYWORD)\
	DEF("default"DLM,        TOK_DEFAULT,       TOK_KIND_KEYWORD)\
	DEF("continue"DLM,       TOK_CONTINUE,      TOK_KIND_KEYWORD)\
	DEF("_Alignas"DLM,       TOK_ALIGNAS,       TOK_KIND_KEYWORD)\
	DEF("_Alignof"DLM,       TOK_ALIGNOF,       TOK_KIND_KEYWORD)\
	DEF("_Generic"DLM,       TOK_GENERIC,       TOK_KIND_KEYWORD)\
	DEF("_Complex"DLM,       TOK_COMPLEX,       TOK_KIND_KEYWORD)\
	DEF("_Noreturn"DLM,      TOK_NORETURN,      TOK_KIND_KEYWORD)\
	DEF("_Imaginary"DLM,     TOK_IMAGINARY,     TOK_KIND_KEYWORD)\
	DEF("__attribute__"DLM,  TOK_ATTRIBUTE,     TOK_KIND_KEYWORD)\
	DEF("_Static_assert"DLM, TOK_STATIC_ASSERT, TOK_KIND_KEYWORD)\
	/* Type */\
	DEF("int"DLM       , TOK_INT       , TOK_KIND_TYPE)\
	DEF("enum"DLM      , TOK_ENUM      , TOK_KIND_TYPE)\
	DEF("char"DLM      , TOK_CHAR      , TOK_KIND_TYPE)\
	DEF("long"DLM      , TOK_LONG      , TOK_KIND_TYPE)\
	DEF("void"DLM      , TOK_VOID      , TOK_KIND_TYPE)\
	DEF("bool"DLM      , TOK_BOOL      , TOK_KIND_TYPE)\
	DEF("union"DLM     , TOK_UNION     , TOK_KIND_TYPE)\
	DEF("float"DLM     , TOK_FLOAT     , TOK_KIND_TYPE)\
	DEF("short"DLM     , TOK_SHORT     , TOK_KIND_TYPE)\
	DEF("_Bool"DLM     , TOK_BOOL      , TOK_KIND_TYPE)\
	DEF("signed"DLM    , TOK_SIGNED    , TOK_KIND_TYPE)\
	DEF("struct"DLM    , TOK_STRUCT    , TOK_KIND_TYPE)\
	DEF("double"DLM    , TOK_DOUBLE    , TOK_KIND_TYPE)\
	DEF("size_t"DLM    , TOK_SIZE_T    , TOK_KIND_TYPE)\
	DEF("int8_t"DLM    , TOK_INT8_T    , TOK_KIND_TYPE)\
	DEF("uint8_t"DLM   , TOK_UINT8_T   , TOK_KIND_TYPE)\
	DEF("wchar_t"DLM   , TOK_WCHAR_T   , TOK_KIND_TYPE)\
	DEF("int16_t"DLM   , TOK_INT16_T   , TOK_KIND_TYPE)\
	DEF("int32_t"DLM   , TOK_INT32_T   , TOK_KIND_TYPE)\
	DEF("int64_t"DLM   , TOK_INT64_T   , TOK_KIND_TYPE)\
	DEF("uint16_t"DLM  , TOK_UINT16_T  , TOK_KIND_TYPE)\
	DEF("uint32_t"DLM  , TOK_UINT32_T  , TOK_KIND_TYPE)\
	DEF("unsigned"DLM  , TOK_UNSIGNED  , TOK_KIND_TYPE)\
	DEF("uint64_t"DLM  , TOK_UINT64_T  , TOK_KIND_TYPE)\
	DEF("ptrdiff_t"DLM , TOK_PTRDIFF_T , TOK_KIND_TYPE)

#define DEF_TOK_QUOTE(DEF, DEF_RANGE)\
	/* Quote */\
	DEF("\"",  TOK_DQUOTE,   TOK_KIND_QUOTE)\
	DEF("\'",  TOK_SQUOTE,   TOK_KIND_QUOTE)\
	DEF("`",   TOK_BACKTICK, TOK_KIND_QUOTE)\
	/* Escape */\
	DEF("\\"  /*92*/  , TOK_BACKSLASH     , TOK_KIND_ESCAPE)\
	DEF("\\0" /*NUL*/ , TOK_ESC_NULL      , TOK_KIND_ESCAPE)\
	DEF("\\a" /*BEL*/ , TOK_ESC_ALERT     , TOK_KIND_ESCAPE)\
	DEF("\\b" /*BS*/  , TOK_ESC_BACKSPACE , TOK_KIND_ESCAPE)\
	DEF("\\t" /*TAB*/ , TOK_ESC_TAB       , TOK_KIND_ESCAPE)\
	DEF("\\n" /*LF*/  , TOK_ESC_NEWLINE   , TOK_KIND_ESCAPE)\
	DEF("\\v" /*VT*/  , TOK_ESC_VTAB      , TOK_KIND_ESCAPE)\
	DEF("\\f" /*FF*/  , TOK_ESC_FORMFEED  , TOK_KIND_ESCAPE)\
	DEF("\\r" /*CR*/  , TOK_ESC_RETURN    , TOK_KIND_ESCAPE)\
	DEF("\\\\"/*\\*/  , TOK_ESC_BACKSLASH , TOK_KIND_ESCAPE)\
	DEF("\\'" /*'*/   , TOK_ESC_SQUOTE    , TOK_KIND_ESCAPE)\
	DEF("\\\""/*"*/   , TOK_ESC_DQUOTE    , TOK_KIND_ESCAPE)\
	DEF("\\?" /*?*/   , TOK_ESC_QUESTION  , TOK_KIND_ESCAPE)\
	/* Hex Prefix */\
	DEF("\\x", TOK_ESC_HEX, TOK_KIND_ESCAPE)\
	/* Unicode Prefix */\
	DEF("\\u", TOK_ESC_UNICODE4, TOK_KIND_ESCAPE)\
	DEF("\\U", TOK_ESC_UNICODE8, TOK_KIND_ESCAPE)\
	/* Octal Prefix TODO how to highlight whole octal? */\
	DEF("\\0", TOK_ESC_OCTAL, TOK_KIND_ESCAPE)\
	DEF("\\1", TOK_ESC_OCTAL, TOK_KIND_ESCAPE)\
	DEF("\\2", TOK_ESC_OCTAL, TOK_KIND_ESCAPE)\
	DEF("\\3", TOK_ESC_OCTAL, TOK_KIND_ESCAPE)\
	DEF("\\4", TOK_ESC_OCTAL, TOK_KIND_ESCAPE)\
	DEF("\\5", TOK_ESC_OCTAL, TOK_KIND_ESCAPE)\
	DEF("\\6", TOK_ESC_OCTAL, TOK_KIND_ESCAPE)\
	DEF("\\7", TOK_ESC_OCTAL, TOK_KIND_ESCAPE)

#define DEF_TOK_LINE_COMMENT(DEF, DEF_RANGE)\
	DEF("*/", TOK_RBLOCK_COMMENT, TOK_KIND_COMMENT)\
	DEF("\n", TOK_NEWLINE,  TOK_KIND_WHITESPACE)

#define DEF_TOK_ALL_DEFINITIONS(DEF)\
	DEF(TOK_BASE)\
	DEF(TOK_QUOTE)\
	DEF(TOK_LINE_COMMENT)

/*
 * Flat Trie Data Structure
 */
#define FRIE_MAX_PACKED_OFFSET  4096  // 12 bit
#define FRIE_MAX_SPARSE_OFFSET  65536 // 16 bit
typedef union PACKED FrieNode {
	/* First 128 ASCII chars are sparse nodes. Char token is index. */
	struct PACKED {
		u32  tok :  8;  // If single char token this will be set. Otherwise it is TOK_ERR.
		u32  succ : 16; // Amount to jump into packed tokens.
		u32  kind : 8;  // Token Kind if it is a token.
	} sparse;
	/* All tokens past first 128 ASCII chars are packed nodes. Can contain TOK_DELIMIT or TOK_MUNCH nodes. */
	struct PACKED {
		u32  tok  : 8;  // Token Value. 0-7 Special Frie Token. 32-128 ASCII Tokens. >128 Keyword Tokens
		u32  succ : 12; // Offset to jump on success.
		u32  fail : 12; // offset to jump on fail.
	} packed;
	/* Endpoint token node. Error or Keword token. Frie exits when ecnountering these. */
	struct PACKED {
		u32   tok  : 8;  // Token Value. 0-7 Special Frie Token. 32-128 ASCII Tokens. >128 Keyword Tokens
		u32   kind : 8;  // Token kind.
		u32   pad  : 16; // 10 more bits available
	} terminator;
	u32 raw; // Must use u32 for everything to ensure union packs to 4 bytes. Differing types makes the compiler add arbitrary packing.
} FrieNode;
STATIC_ASSERT(sizeof(FrieNode) == 4);

typedef struct FrieTokDef {
	char* name;
	u16 kind;
} FrieTokDef;

#define STR_LEN(_str) (sizeof(_str) - 1)
#define DEF_TOK_DEF_ITEM(_name, _tok, _kind)  [_tok]   = (FrieTokDef){ _name,          _kind },
#define DEF_TOK_RANGE_DEF_ITEM(_range, _kind) [_range] = (FrieTokDef){ TOK_RANGE_NAME, _kind },
#define DEF_TOK_DEFINITIONS(_tok)\
	static const FrieTokDef _tok##_DEFS[] = { DEF_##_tok(DEF_TOK_DEF_ITEM, DEF_TOK_RANGE_DEF_ITEM) };\
	static FrieNode _tok##_FRIE[1024];

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Woverride-init"
#define DEF_TOK_DEFINITIONS_ALL(_defs) _defs(DEF_TOK_DEFINITIONS)
	DEF_TOK_DEFINITIONS_ALL(DEF_TOK_ALL_DEFINITIONS)
#pragma GCC diagnostic pop // ignored "-Woverride-init"

/*
 * Flat Trie Functions
 */

static void FrieLog(FrieNode* trie)
{
	LOG("Frie:\n");
	int iNode = 0; FrieNode node = trie[iNode];
	fprintf(stderr,
		"Sparse Table: "
		ANSI_DIM ANSI_YELLOW ANSI_UNDERLINE "index"
		ANSI_RESET ANSI_WHITE "char"
		ANSI_DIM ANSI_ITALIC ANSI_YELLOW "SuccessTarget\n "
		ANSI_RESET);
	while ( iNode < TOK_KEYWORD_BEGIN) {
		fprintf(stderr,
			ANSI_DIM ANSI_YELLOW ANSI_UNDERLINE "%d"
			ANSI_RESET ANSI_WHITE "%s"
			ANSI_DIM ANSI_ITALIC ANSI_YELLOW "%d"
			ANSI_WHITE "%s"
			ANSI_BRIGHT_BLACK "|"
			ANSI_RESET,
			iNode, string_CHAR(iNode), node.sparse.succ, string_TOK(node.sparse.tok));
		node = trie[++iNode];
	}
	fprintf(stderr,
		"\nPacked Trie: " ANSI_DIM ANSI_YELLOW ANSI_UNDERLINE
		"index" ANSI_RESET ANSI_WHITE "char/token"
		ANSI_DIM ANSI_GREEN "SuccessOffset"
		ANSI_ITALIC ANSI_YELLOW "SuccessTarget"
		ANSI_RESET ANSI_DIM ANSI_RED "FailOffset"
		ANSI_RESET ANSI_ITALIC ANSI_DIM ANSI_YELLOW
		"FailTarget\n"
		ANSI_RESET);
	while (node.packed.tok != '\0' || iNode < 128) {
		if (IS_DELIM_TOKEN(node.packed.tok))
			fprintf(stderr,
				ANSI_DIM ANSI_YELLOW ANSI_UNDERLINE "%d"
				ANSI_RESET ANSI_DIM ANSI_WHITE ANSI_ITALIC "%s"
				ANSI_DIM ANSI_GREEN "%d"
				ANSI_ITALIC ANSI_YELLOW "%d"
				ANSI_RESET ANSI_DIM ANSI_RED "%d"
				ANSI_RESET ANSI_ITALIC ANSI_DIM ANSI_YELLOW "%d"
				ANSI_BRIGHT_BLACK "|"
				ANSI_RESET,
				iNode, string_TOK(node.packed.tok), node.packed.succ, node.packed.succ+iNode, node.packed.fail, node.packed.fail+iNode);
		else if (IS_KEYWORD_OR_SPECIAL_TOKEN(node.packed.tok))
			fprintf(stderr,
				ANSI_DIM ANSI_YELLOW ANSI_UNDERLINE "%d"
				ANSI_RESET ANSI_DIM ANSI_WHITE ANSI_ITALIC "%s"
				ANSI_BRIGHT_BLACK "%c"
				ANSI_RESET,
				iNode, string_TOK(node.terminator.tok), node.terminator.tok == TOK_ERR ? '\n' : '|');
		else
			fprintf(stderr,
				ANSI_DIM ANSI_YELLOW ANSI_UNDERLINE "%d"
				ANSI_RESET ANSI_WHITE "%c"
				ANSI_DIM ANSI_GREEN "%d"
				ANSI_ITALIC ANSI_YELLOW "%d"
				ANSI_RESET ANSI_DIM ANSI_RED "%d"
				ANSI_RESET ANSI_ITALIC ANSI_DIM ANSI_YELLOW "%d"
				ANSI_BRIGHT_BLACK "|"
				ANSI_RESET,
				iNode, node.packed.tok, node.packed.succ, node.packed.succ+iNode, node.packed.fail, node.packed.fail+iNode);
		node = trie[++iNode];
	}
	fprintf(stderr, "\n");
}

static TOK FrieGet(const char *pText, FrieNode *pFrie)
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Woverride-init"

	static void *dispatch[TOK_CAPACITY] = {
		[TOK_ALL_RANGE]     = &&TOK_NONE,
		[TOK_PACKED_CHAR]   = &&TOK_PACKED_CHAR,
		[TOK_DELIMIT]       = &&TOK_DELIMIT,
		[TOK_ASCII_RANGE]   = &&TOK_ALL,
		[TOK_KEYWORD_RANGE] = &&TOK_ALL,
	};

#pragma GCC diagnostic pop

	struct PACKED {
		int      iText;
		int      iPack;
		int      startTok;
		int      tok;
		FrieNode node;
		char     cText;
	} step; ZERO(&step);

	{
		step.cText = pText[0];
		step.node = pFrie[(u8)step.cText];
		step.startTok = step.node.sparse.tok;
		bool jump = step.node.sparse.succ > 0;
		step.iPack  = step.node.sparse.succ;
		step.tok = jump ? TOK_PACKED_CHAR :step.node.sparse.tok;
		step.cText  = pText[++step.iText];
		step.node  = pFrie[step.iPack];
		goto *dispatch[step.tok];
	}

TOK_PACKED_CHAR:
	{
		bool match = step.node.packed.tok == step.cText;
		step.iPack += match ? step.node.packed.succ : step.node.packed.fail;
		step.node   = pFrie[step.iPack];
		step.iText += match; step.cText = pText[step.iText];
		step.tok = IS_KEYWORD_OR_SPECIAL_TOKEN(step.node.packed.tok) ? step.node.packed.tok : TOK_PACKED_CHAR;
		goto *dispatch[step.tok];
	}

TOK_DELIMIT:
	{
		bool delim = IS_DELIM_CHAR(step.cText);
		step.iPack += delim ? step.node.packed.succ : step.node.packed.fail;
		step.node  = pFrie[step.iPack];
		step.tok = IS_KEYWORD_OR_SPECIAL_TOKEN(step.node.packed.tok) ? step.node.packed.tok : TOK_PACKED_CHAR;
		goto *dispatch[step.tok];
	}

TOK_ALL:
	return step.tok;

TOK_NONE:
	return step.startTok;
}

static void FrieValidate(int tokCount, const FrieTokDef* tokDefs, FrieNode* pFrie)
{
	char sparseCharBuf[2] = { '\0', '\0' };
	for (int iTok = TOK_ASCII_BEGIN; iTok < tokCount; ++iTok) {
		FrieTokDef def = tokDefs[iTok];
		if (def.name == NULL) continue;
		if (def.name[0] == TOK_RANGE) {	def.name = sparseCharBuf; def.name[0] = iTok; }
		TOK tok = FrieGet(def.name, pFrie);
		LOG("%s  %d:%s expected:%d:%s\n", def.name, tok, string_TOK(tok), iTok, string_TOK(iTok));
		MUST(tok == iTok);
	}
}

/* Shift all frie nodes right by 1 updating all offsets. */
static void FrieShift(FrieNode* pFrie, int iInsertNode, int iEndNode)
{
	// Shift all to right by 1 to make room for new char condition.
	memmove(pFrie + iInsertNode + 1, pFrie + iInsertNode, (iEndNode - iInsertNode) * sizeof(FrieNode));

	// Increment sparse ascii jump values if they would have jumped past current insertion
	for (int iNodePrev = 0; iNodePrev < TOK_KEYWORD_BEGIN; iNodePrev++) {
		FrieNode *pPrevNode = pFrie + iNodePrev;
		if (pPrevNode->sparse.succ > iInsertNode) pPrevNode->sparse.succ++;
	}

	// Increment all fail succ values in prior trie steps if they would have jumped past current insertion
	for (int iNodePrev = TOK_KEYWORD_BEGIN; iNodePrev < iInsertNode; iNodePrev++) {
		FrieNode *pPrevNode = pFrie + iNodePrev;
		int diff = iInsertNode - iNodePrev;
		if (IS_KEYWORD_TOKEN(pPrevNode->packed.tok)) continue;
		if (pPrevNode->packed.succ > diff) pPrevNode->packed.succ++;
		if (pPrevNode->packed.fail > diff) pPrevNode->packed.fail++;
	}
}

static RESULT ConstructFrie(int tokCount, const FrieTokDef* tokDefs, int frieCapacity, FrieNode* pFrie)
{
	FrieTokDef def = { .name = "\0" };
	int iEndNode = TOK_KEYWORD_BEGIN;
	int iNodeFirstFail = 0;
	int iTok   = 0;
	int iNode  = 0;
	int iName  = 0;
	int len    = 0;
	bool munch = false;
	bool delim = false;
	TOK tok    = TOK_NONE;
	char sparseCharBuf[2] = { '\0', '\0' };

	CHECK(frieCapacity > 256, RESULT_CAPACITY_ERROR);
	ZERO_RANGE(pFrie, frieCapacity);
	for (int i = 1; i < TOK_KEYWORD_BEGIN; ++i) {
		pFrie[i].sparse.tok  = TOK_ERR;
		pFrie[i].sparse.kind = TOK_KIND_ERROR;
	}

NextTok:
	if (iTok == tokCount) goto RESULT_SUCCESS;
	def = tokDefs[iTok];
	if (def.name == NULL) {	iTok++; goto NextTok; }
	if (def.name[0] == TOK_RANGE) {	def.name = sparseCharBuf; def.name[0] = iTok; }
	iNodeFirstFail = TOK_KEYWORD_BEGIN;
	iNode = 0;
	iName = 0;
	len = strlen(def.name);
	munch = false;
	delim = def.name[len-1] == TOK_DELIMIT;
	tok = iTok;

NextNameChar:
	char cName = def.name[iName];
	if (cName == '\0' && iName == 0) {
		LOG_WARN("Trying to add empty token!\n");
		iTok++; goto NextTok;
	}
	char cNameNext= def.name[iName+1];

	/* Token First Char */
	if (iName == 0) {
		FrieNode *pNode = pFrie + cName;
		FrieNode node = *pNode;

		// One char token
		if (cNameNext == '\0') {
			pNode->sparse.kind = def.kind;
			CHECKMSG(pNode->sparse.tok != TOK_SPARSE_CHAR, RESULT_DUPLICATE_ERROR, "Trying to insert single char token twice! %s %s %s", def.name, string_CHAR(cName), string_TOK(tok));
			pNode->sparse.tok = tok;
			iTok++;
			goto NextTok;
		}

		// Already added. Jump.
		if (node.sparse.succ > 0) {
			if (node.sparse.tok != TOK_ERR) munch = true;
			iNode = node.sparse.succ;
			iName++;
			goto NextNameChar;
		}

		// Set succ on sparse token to signal a match
		CHECKMSG(iEndNode < FRIE_MAX_SPARSE_OFFSET, RESULT_OFFSET_ERROR, "end offset:%d", iEndNode);
		if (node.sparse.tok != TOK_ERR) munch = true;
		pNode->sparse.succ = iEndNode;
		iNode = iEndNode;
		iName++;
		goto NextNameChar;
	}

	/* Token Subsequent Chars */
	{
		FrieNode node  = pFrie[iNode];
		// Encounter a token, must shift to the right and fill in new token.
		if (IS_KEYWORD_TOKEN(node.packed.tok) || node.packed.tok == TOK_ERR || node.packed.tok == TOK_MUNCH) {
			if (iNodeFirstFail != TOK_KEYWORD_BEGIN) iNode = iNodeFirstFail;
			FrieShift(pFrie, iNode, iEndNode);
			iEndNode++; CHECK(iEndNode < frieCapacity, RESULT_CAPACITY_ERROR);
			u16 succ = iEndNode - iNode;
			CHECKMSG(succ < FRIE_MAX_PACKED_OFFSET, RESULT_OFFSET_ERROR, "succ offset:%d", succ);
			pFrie[iNode] = (FrieNode){
				.packed.tok  = cName,
				.packed.succ = succ,
				// When non-delim, fail = 1 ends up pointing to the token to be munched
				// whereas with delim fail will point to a delim token, which will then go to err token
				.packed.fail = 1
			};
			iName++; iNode = iEndNode;
			goto NextNameChar;
		}

		// Encounter delimit char, must shift to the right and fill in new token.
		if (cName == TOK_DELIMIT) {
			FrieShift(pFrie, iNode, iEndNode);
			bool insertingAtEnd = iEndNode == iNode;
			iEndNode++; CHECK(iEndNode < frieCapacity, RESULT_CAPACITY_ERROR);
			u16 succ = iEndNode - iNode;
			CHECKMSG(succ < FRIE_MAX_PACKED_OFFSET, RESULT_OFFSET_ERROR, "succ offset:%d", succ);
			u16 fail = insertingAtEnd ? succ + 1 : 1; // If inserting at end ERR token is 1 after succ, otherwise fail to next node
			CHECKMSG(fail < FRIE_MAX_PACKED_OFFSET, RESULT_OFFSET_ERROR, "fail offset:%d", fail);
			pFrie[iNode] = (FrieNode){
				.packed.tok  = TOK_DELIMIT,
				.packed.succ = succ,
				.packed.fail = fail,
			};
			delim = true;
			iName++; iNode = iEndNode;
			goto NextNameChar;
		}

		// End of Token Name. Write token go to next token!
		if (cName == '\0') {
			CHECKMSG(iNode == iEndNode, RESULT_ORDER_ERROR, "Trying to inset shorter token after longer token! %s %s", def.name, string_TOK(tok));
			pFrie[iNode++] = (FrieNode){ .terminator.tok = tok, .terminator.kind = def.kind };
			// If the token has a delimiter it will have an explicit end delimit node to signal match. If it gets past the delimiter node it's because there was no match and thus an error.
			// If there is no delimiter it runs on maximal munch and whatever muched thus far should be the token.
			if (munch) pFrie[iNode++] = (FrieNode){ .terminator.tok = TOK_MUNCH, .terminator.kind = TOK_KIND_ERROR };
			else       pFrie[iNode++] = (FrieNode){ .terminator.tok = TOK_ERR,   .terminator.kind = TOK_KIND_ERROR };
			iTok++;	iEndNode = iNode;
			goto NextTok;
		}

		// Token char succesfully match with existing trie char
		if (cName == node.packed.tok) {
			iNodeFirstFail = TOK_KEYWORD_BEGIN;
			iNode += node.packed.succ; iName++;
			goto NextNameChar;
		}

		// Token char fail to match with existing trie char
		if (iNode < iEndNode) {
			if (iNodeFirstFail == TOK_KEYWORD_BEGIN) iNodeFirstFail = iNode;
			iNode += node.packed.fail;
			goto NextNameChar;
		}

		{
			u16 fail = (len + 1) - iName - delim; // +1 as err comes after tok
			CHECKMSG(fail < FRIE_MAX_PACKED_OFFSET, RESULT_OFFSET_ERROR, "fail offset:%d", fail);
			pFrie[iNode] = (FrieNode){
				.packed.tok  = cName,
				.packed.succ = 1,
				.packed.fail = fail,
			};
			iNode++; iEndNode++; iName++;
			goto NextNameChar;
		}
	}

RESULT_ORDER_ERROR:
	LOG_ERR("Trie capacity reached! %d %s\n", iNode, def.name);
	FrieLog(pFrie);
	return RESULT_CAPACITY_ERROR;

RESULT_CAPACITY_ERROR:
	LOG_ERR("Trie capacity reached! %d %s\n", iNode, def.name);
	FrieLog(pFrie);
	return RESULT_CAPACITY_ERROR;

RESULT_DUPLICATE_ERROR:
	LOG_ERR("Trying insert the same token twice! %d %s\n", iNode, def.name);
	FrieLog(pFrie);
	return RESULT_DUPLICATE_ERROR;

RESULT_OFFSET_ERROR:
	LOG_ERR("Trying to add offset greater than FRIE_MAX_OFFSET. %d %s\n", iNode, def.name);
	FrieLog(pFrie);
	return RESULT_OFFSET_ERROR;

RESULT_SUCCESS:
	FrieLog(pFrie);
	FrieValidate(tokCount, tokDefs, pFrie);
	return RESULT_SUCCESS;
}

/*
 * CodeBox
 */
#define DEFAULT_WIDTH  1280
#define DEFAULT_HEIGHT 1024

#define MAX_INPUT_CHARS      2048
#define TEXT_BUFFER_CAPACITY 65536 * 2

#define CASE_EITHER(_key, _a, _b) case _key | _a | _b: case _key | _a: case _key | _b
#define TO_LOWER_C(_c) 'a' + (_c - 'A')

const int endCharLength = 1;
const int tabWidth = 4;
const int fontSize = 18;
const int fontYSpacing =  fontSize;
const int fontXSpacing = (fontSize - 2) / 2;
const char availableChars[] = " abcdefghijklmnopqrstuvwxyzABDCEFGHIJKLMNOPQRSTUVWXYZ1234567890-=!@#$%^&*()_+[];',./{}:\"<>?|`~\n\t\\";

#define CARET_MAX_CAPACITY 8
#define CARET_INVALID INT_MIN
            
//                   0b0000111122223333
#define MASK_ASCII   0b0000000011111111
#define MASK_KEYS    0b0000001111111111
#define MASK_SHIFT    0b1000000000000000
#define MASK_ALT      0b0100000000000000
#define MASK_CTRL     0b0010000000000000
#define MASK_ALT_CTRL 0b0001000000000000
#define MASK_CTRL_ALT 0b0000100000000000

typedef struct u8_span {
	u8 iStart;
	u8 iEnd;
} u8_span;

typedef struct TokMeta {
	TOK 	 val;
	TOK_KIND kind;
} TokMeta;

typedef struct PACKED TextMeta {
	TokMeta tok;
 	u8_span tokOffset;
	u8 braceLevel;
	u8 bracketLevel;
	u8 parenLevel;
} TextMeta;

typedef struct CodeCommand {


} CodeCommand;

typedef struct CodeRow {
	int startIndex;
	int endIndex;
} CodeRow;

typedef struct CodePos {
	int index;
	int row;
	int col;
} CodePos;

typedef struct CodeBox {
	bool dirty;

	Rectangle rect;
	int focusStartRowIndex;
	int focusStartRow;

	int 	 caretCount;
	CodePos *pCarets;
	CodePos  mark;

	int boxRowCount;
	int boxColCount;

	int textRowCount;
	int textCount;
	char*     pText;
	TextMeta* pTextMeta;
	char*     pTextPath;
} CodeBox;

typedef struct Command {
	bool enabled;
	bool toggled;
	bool skipCount;
	bool firstKeyPressed;

	int  scanFoundIndex;

	int  bufferCount;
	char buffer[32];
} Command;

static inline Vector2 GetWorldToBoxLocal(Vector2 point, Rectangle rect) {
	return (Vector2){ point.x - rect.x, point.y - rect.y };
}

static inline Vector2 GetBoxLocalToWorld(Vector2 point, Rectangle rect) {
	return (Vector2){ point.x + rect.x, point.y + rect.y };
}

static RESULT CodeBoxProcessMeta(CodeBox* pCode)
{
// Dispatch tables are built by filling in ranges of defaults
// and subsequent assignments overriding what they need.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Woverride-init"

	/* Base Dispatch */
	#define DISPATCH_DEEFAULT\
		[TOK_ALL_RANGE]     = &&TOK_ERR,\
		[TOK_NONE]          = &&TOK_NONE,\
		[TOK_MUNCH]         = &&TOK_MUNCH,\
		[TOK_SPARSE_CHAR]   = &&TOK_SPARSE_CHAR,\
		[TOK_PACKED_CHAR]   = &&TOK_PACKED_CHAR,\
		[TOK_DELIMIT]       = &&TOK_DELIMIT,\
		[TOK_ASCII_RANGE]   = &&TOK_SPARSE_CHAR,\
		[TOK_WHITE_RANGE]   = &&TOK_SPARSE_WHITESPACE,\
		[' ']               = &&TOK_SPARSE_WHITESPACE,\
		[TOK_KEYWORD_RANGE] = &&TOK_ALL,

	static void *baseDispatch[TOK_CAPACITY] = {
		DISPATCH_DEEFAULT
		[TOK_SQUOTE]            = &&TOK_SQUOTE_BEGIN,
		[TOK_DQUOTE]            = &&TOK_DQUOTE_BEGIN,
		[TOK_LBLOCK_COMMENT]    = &&TOK_OPEN_BLOCK_COMMENT,
		[TOK_LINE_COMMENT]      = &&TOK_OPEN_LINE_COMMENT,
		[TOK_UPPER_ALPHA_RANGE] = &&TOK_SPARSE_IDENTIFIER_BEGIN,
		[TOK_LOWER_ALPHA_RANGE] = &&TOK_SPARSE_IDENTIFIER_BEGIN,
		['_']                   = &&TOK_SPARSE_IDENTIFIER_BEGIN,
		[TOK_DIGIT_RANGE]       = &&TOK_SPARSE_NUMBER_BEGIN,
		['{']                   = &&TOK_LBRACE,
		['}']                   = &&TOK_RBRACE,
		['[']                   = &&TOK_LBRACKET,
		[']']                   = &&TOK_RBRACKET,
		['(']                   = &&TOK_LPAREN,
		[')']                   = &&TOK_RPAREN,
	};

	/* State */
	struct PACKED {
		FrieNode node;
		char     cText;
		int      iText;
		int      iPack;
		int      iTextStart;
		TOK      tok;
		TextMeta meta;
	} step;	ZERO(&step);

	const int  textCount = pCode->textCount;
	char	  *pText     = pCode->pText;
	TextMeta  *pMeta     = pCode->pTextMeta;
	void     **basedisp  = baseDispatch;
	void     **disp      = baseDispatch;
	FrieNode  *pFrie     = TOK_BASE_FRIE;

	/* Entry */
	step.iText = 0;
	step.cText = pText[step.iText];
	step.node  = pFrie[(u8)step.cText];

	/* Sparse Char Tokens */
	TOK_SPARSE_WHITESPACE: { 
		// White space is most common so we rely on fallthrough.
		step.node.sparse.kind = TOK_KIND_WHITESPACE;
		// Fallthrough
	}
	TOK_SPARSE_CHAR: {
		step.meta.tok = (TokMeta){ step.cText, step.node.sparse.kind };
		// Fallthrough
	}
	TOK_SPARSE_META_COPY: {
		ZERO(&step.meta.tokOffset);
		memcpy(pMeta + step.iText, &step.meta, sizeof(TextMeta));
		step.iTextStart  = step.iText;
		// Fallthrough
	}
	TOK_SPARSE_DISP: {
		bool jump  = step.node.sparse.succ > 0;
		step.cText = pText[++step.iText];
		u8 cTok    = step.cText > 0 ? step.cText : TOK_ERR;
		step.tok   = jump ? TOK_PACKED_CHAR : cTok;
		step.iPack = jump ? step.node.sparse.succ : cTok;
		step.node  = pFrie[step.iPack];
		goto *disp[step.tok];
	}
	TOK_SPARSE_STEP: {
		step.cText = pText[++step.iText];
		step.tok   = step.cText < 0 ? TOK_ERR : step.cText;
		step.node  = pFrie[step.tok];
		goto *disp[step.tok];
	}
	TOK_SPARSE_END: {
		for (int i = step.iTextStart; i < step.iText; ++i) {
			step.meta.tokOffset = (u8_span){ i - step.iTextStart, (step.iText-1) - i };
			pMeta[i] = step.meta;
		}
		disp = baseDispatch;
		goto *disp[step.tok];
	}

	/* Alternate Sparse Char Tokens */
	TOK_SPARSE_STRING: {
		step.meta.tok = (TokMeta){ TOK_STRING, TOK_KIND_STRING };
		goto TOK_SPARSE_META_COPY;
	}
	TOK_SPARSE_COMMENT: {
		step.meta.tok = (TokMeta){ TOK_COMMENT, TOK_KIND_COMMENT };
		goto TOK_SPARSE_META_COPY;
	}

	/* Sparse Number */
	TOK_SPARSE_NUMBER_BEGIN: {
		static void *numberDispatch[TOK_CAPACITY] = {
			DISPATCH_DEEFAULT
			[TOK_WHITE_RANGE]       = &&TOK_SPARSE_END,
			[' ']                   = &&TOK_SPARSE_END,
			[TOK_ASCII_RANGE]       = &&TOK_SPARSE_END,
			[TOK_UPPER_ALPHA_RANGE] = &&TOK_SPARSE_END,
			[TOK_LOWER_ALPHA_RANGE] = &&TOK_SPARSE_END,
			[TOK_NUMBER_BINARY]     = &&TOK_SPARSE_STEP,
			[TOK_NUMBER_HEX]        = &&TOK_SPARSE_STEP,
			[TOK_DIGIT_RANGE]       = &&TOK_SPARSE_STEP,
		};
		step.iTextStart   = step.iText;
		step.meta.tok = (TokMeta){ TOK_NUMBER, TOK_KIND_NUMBER };
		disp = numberDispatch;
		goto TOK_SPARSE_DISP;
	}

	/* Sparse Identifier */
	TOK_SPARSE_IDENTIFIER_BEGIN: {
		static void *identifierDispatch[TOK_CAPACITY] = {
			DISPATCH_DEEFAULT
			[TOK_WHITE_RANGE]       = &&TOK_SPARSE_END,
			[' ']                   = &&TOK_SPARSE_END,
			[TOK_ASCII_RANGE]       = &&TOK_SPARSE_END,
			[TOK_UPPER_ALPHA_RANGE] = &&TOK_SPARSE_STEP,
			[TOK_LOWER_ALPHA_RANGE] = &&TOK_SPARSE_STEP,
			['_']                   = &&TOK_SPARSE_STEP,
			[TOK_DIGIT_RANGE]       = &&TOK_SPARSE_STEP,
		};
		step.iTextStart   = step.iText;
		step.meta.tok = (TokMeta){ TOK_IDENTIFIER, TOK_KIND_IDENTIFIER };
		disp = identifierDispatch;
		goto TOK_SPARSE_DISP;
	}

	/* Scope Tokens */
#define TOK_SCOPE(_ltok, _rtok, _level)\
	_ltok: {\
		step.meta.tok = (TokMeta){ _ltok, TOK_KIND_SCOPE };\
		step.meta._level++;\
		ZERO(&step.meta.tokOffset);\
		pMeta[step.iText] = step.meta;\
		goto TOK_SPARSE_DISP;\
	}\
	_rtok: {\
		step.meta.tok = (TokMeta){ _rtok, TOK_KIND_SCOPE };\
		ZERO(&step.meta.tokOffset);\
		pMeta[step.iText] = step.meta;\
		step.meta._level--;\
		goto TOK_SPARSE_DISP;\
	}

	TOK_SCOPE(TOK_LPAREN,   TOK_RPAREN,   parenLevel)
	TOK_SCOPE(TOK_LBRACKET, TOK_RBRACKET, bracketLevel)
	TOK_SCOPE(TOK_LBRACE,   TOK_RBRACE,   braceLevel)

#undef TOK_SCOPE

	/* Quote Tokens */
	TOK_SQUOTE_BEGIN: {
		static void *squoteispatch[TOK_CAPACITY] = {
			DISPATCH_DEEFAULT
			[TOK_ASCII_RANGE] = &&TOK_SPARSE_STRING,
			[' ']             = &&TOK_SPARSE_WHITESPACE,
			['\'']            = &&TOK_QUOTE_END,
		};
		basedisp = squoteispatch;
		disp     = squoteispatch;
		pFrie = TOK_QUOTE_FRIE;
		goto TOK_SPARSE_CHAR;
	}
	TOK_DQUOTE_BEGIN: {
		static void *dquoteDispatch[TOK_CAPACITY] = {
			DISPATCH_DEEFAULT
			[TOK_ASCII_RANGE] = &&TOK_SPARSE_STRING,
			[' ']             = &&TOK_SPARSE_WHITESPACE,
			['"']             = &&TOK_QUOTE_END,
		};
		basedisp = dquoteDispatch;
		disp     = dquoteDispatch;
		pFrie = TOK_QUOTE_FRIE;
		goto TOK_SPARSE_CHAR;
	}
	TOK_QUOTE_END: {
		basedisp = baseDispatch;
		disp     = baseDispatch;
		pFrie = TOK_BASE_FRIE;
		goto TOK_SPARSE_CHAR;
	}

	/* Comment Tokens */
	TOK_CLOSE_BLOCK_COMMENT: {
		basedisp = baseDispatch;
		disp     = baseDispatch;
		pFrie = TOK_BASE_FRIE;
		goto TOK_ALL;
	}
	TOK_OPEN_BLOCK_COMMENT: {
		static void *blockCommentDispatch[TOK_CAPACITY] = {
			DISPATCH_DEEFAULT
			[TOK_RBLOCK_COMMENT] = &&TOK_CLOSE_BLOCK_COMMENT,
			[TOK_ASCII_RANGE]    = &&TOK_SPARSE_COMMENT,
			[' ']                = &&TOK_SPARSE_WHITESPACE,
		};
		basedisp = blockCommentDispatch;
		disp     = blockCommentDispatch;
		pFrie = TOK_LINE_COMMENT_FRIE;
		goto TOK_ALL;
	}
	TOK_CLOSE_LINE_COMMENT:	{
		basedisp = baseDispatch;
		disp  = baseDispatch;
		pFrie = TOK_BASE_FRIE;
		goto TOK_SPARSE_CHAR;
	}
	TOK_OPEN_LINE_COMMENT: {
		static void *lineCommentDispatch[TOK_CAPACITY] = {
			DISPATCH_DEEFAULT
			[TOK_NEWLINE]     = &&TOK_CLOSE_LINE_COMMENT,
			[TOK_ASCII_RANGE] = &&TOK_SPARSE_COMMENT,
			[' ']             = &&TOK_SPARSE_WHITESPACE,
		};
		basedisp = lineCommentDispatch;
		disp     = lineCommentDispatch;
		pFrie = TOK_LINE_COMMENT_FRIE;
		goto TOK_ALL;
	}

	/* Packed Tokens */
	TOK_PACKED_CHAR: {
		bool match = step.node.packed.tok == step.cText;
		step.iPack += match ? step.node.packed.succ : step.node.packed.fail;
		step.iText += match;
		step.node  = pFrie[step.iPack];
		step.cText = pText[step.iText];
		// Single char tokens are dispatched from SPARSE_DISP. Continue as PACKED if in single char ASCII range.
		step.tok = IS_KEYWORD_OR_SPECIAL_TOKEN(step.node.packed.tok) ? step.node.packed.tok : TOK_PACKED_CHAR;
		goto *disp[step.tok];
	}

	/* End Tokens */
	TOK_ALL: {
		step.meta.tok = (TokMeta){ step.node.terminator.tok, step.node.terminator.kind };
		// fallthrough
	}
	TOK_MUNCH: {
		for (int i = step.iTextStart; i < step.iText; ++i) {
			step.meta.tokOffset = (u8_span){ i - step.iTextStart, (step.iText-1) - i };
			pMeta[i] = step.meta;
		}
		disp = basedisp;
		step.tok  = step.cText < 0 ? TOK_ERR : step.cText;
		step.node = pFrie[step.tok];
		goto *disp[step.tok];
	}

	/* Continue Tokens */
	TOK_DELIMIT: {
		disp = basedisp;
		step.iPack += IS_DELIM_CHAR(step.cText) ? step.node.packed.succ : step.node.packed.fail;
		step.node   = pFrie[step.iPack];
		// Single char tokens are dispatched from SPARSE_DISP. Continue as PACKED if in single char ASCII range.
		step.tok = IS_KEYWORD_OR_SPECIAL_TOKEN(step.node.packed.tok) ? step.node.packed.tok : TOK_PACKED_CHAR;
		goto *disp[step.tok];
	}
	TOK_ERR: {
		step.tok  = step.cText < 0 ? TOK_SPARSE_CHAR : step.cText;
		step.node = pFrie[step.tok];
		goto *disp[step.tok];
	}

	/* End Of File */
	TOK_NONE:
		goto RESULT_SUCCESS;

#pragma GCC diagnostic pop // ignored "-Woverride-init"

RESULT_SUCCESS:
	return RESULT_SUCCESS;
}

/*
 * Codebox Text Search
 */

// Find specified char.
static int TextFindCharBackward(const char* text, int index, char c)
{
	while (index >= 0 && text[index] != c) index--;
	return index;
}

// Find specified char.
static int TextFindCharForward(const char* pText, int index, char c)
{
	while (pText[index] != c && pText[index] != '\0') index++;
	return index;
}

// Find specified substring.
static int TextFindTextBackward(const char* text, int index, const char* find)
{
	while (index >= 0) {
		int i = 0; while (text[index + i] == find[i])
			if (find[++i] == '\0') return index;
		index--;
	}
	return index;
}

/* Find specified substring. Will return end null terminator index if it doesn't find. */
static int TextFindTextForward(const char* text, int index, const char* find)
{
	const char* s = text;
	int foundIndex = index;
	while (s[foundIndex] != '\0') {
		int i = 0; while (s[foundIndex + i] == find[i])
			if (find[++i] == '\0') return foundIndex;
		foundIndex++;
	}
	return index;
}

static int TextFindTextsForward(const char* text, int index, const char** finds)
{
	while (text[index] != '\0') {
		int f = 0; while (finds[f] != NULL) {
			const char* find = finds[f++];
			int i = 0; while (text[index + i] == find[i])
				if (find[++i] == '\0') return index;
		}
		index++;
	}
	return -1;
}

/* Test if Text exactly equals given text. 0 if false. strlen of equals if true. */
static int TextEqualsText(const char* text, const char* equals)
{
	assert(equals[0] != '\0');
	int index = 0;
	while (text[index] == equals[index] && text[index] != '\0')
		if (equals[++index] == '\0') return index;
	return 0;
}

/* Find first char which is not the specified char. */
static int TextNegateFindCharBackward(const char* text, int index, char find)
{
	while (index >= 0 && text[index] == find) index--;
	return index;
}

/* Find first char which is not the specified char. */
static int TextNegateFindCharForward(const char* text, int index, char find)
{
	while (text[index] == find && text[index] != '\0') index++;
	return index;
}

static int TextFindCharsForward(const char* text, int index, const char* find)
{
	while (text[index] != '\0') {
		int i = 0; while (find[i] != '\0')
			if (text[index] == find[i++]) return index;
		index++;
	}
	return index;
}

static int TextFindCharsBackward(const char* text, int index, const char* find)
{
	while (index >= 0) {
		int i = 0; while (find[i] != '\0')
			if (text[index] == find[i++]) return index;
		index--;
	}
	return index;
}

/*/ Find char skipping a specified number of matches. */
static int TextFindCharSkipForward(const char* pText, int index, char find, int skipCount)
{
	while (pText[index] != '\0' && skipCount > 0) {
		if (pText[index] == find) skipCount--;
		index++;
	}
	return index;
}

/* Count occurances of char. */
static int TextCountCharForward(const char* text, int index, int range, char find)
{
	int count = 0;
	for (; index < range; ++index) {
		if (text[index] == find) count++;
		if (text[index] == '\0') break;
	}
	return count;
}

/* Find char index and also count occurense of another char during scan. */
static bool TextFindCountCharForward(const char* pText, char searchChar, char countChar, int* pFoundIndex, int *pCount)
{
	int index = *pFoundIndex, count = *pCount;
	char c;	do {
		c = pText[index++];
		count += c == countChar;
	} while (c && c != searchChar);
	*pFoundIndex = index - 1; *pCount = count;
	return c == searchChar;
}

/* Find char index and also count occurense of another char during scan. */
static bool TextFindCountCharBackward(const char* pText, char searchChar, char countChar, int* pFoundIndex, int *pCount)
{
	int index = *pFoundIndex;
	while (pText[index] != searchChar) {
		if (pText[index] == countChar) *pCount = *pCount + 1;
		if (index <= 0) return false;
		index--;
	}
	*pFoundIndex = index;
	return true;
}


static CodeRow CodeRowFromIndex(const char *pText, int index)
{
	return (CodeRow){
		.startIndex = TextFindCharBackward(pText, index-1, '\n')+1,
		.endIndex   = TextFindCharForward(pText,  index,   '\n'),
	};
}

/* Set size rect of CodeBox. */
static void CodeBoxSetRect(CodeBox *pCode, Rectangle rect)
{
	pCode->rect = rect;
	pCode->boxColCount = (int)(pCode->rect.width  / fontXSpacing);
	pCode->boxRowCount = (int)(pCode->rect.height / fontYSpacing);
}

/* The index of char on current line. */
static inline int CodeBoxIndexCol(const CodeBox* pCode, int index)
{
	int lineStartIndex = TextFindCharBackward(pCode->pText, index - 1, '\n') + endCharLength;
	return index - lineStartIndex;
}

/* Line specified index is on. */
static inline int CodeBoxIndexRow(const CodeBox* pCode, int index)
{
	return TextCountCharForward(pCode->pText, 0, index, '\n');
}

/* Focus on a given row. */
static void CodeBoxFocusRow(CodeBox* pCode, int toRow)
{
	int boxRowCount = (int)pCode->boxRowCount;

	int yMin = pCode->focusStartRow;
	if (toRow < yMin) {
		pCode->focusStartRow = toRow;
		pCode->focusStartRowIndex = TextFindCharSkipForward(pCode->pText, 0, '\n', pCode->focusStartRow);
	}

	int yMax = yMin + boxRowCount;
	if (toRow > yMax) {
		pCode->focusStartRow = toRow - boxRowCount;
		pCode->focusStartRowIndex = TextFindCharSkipForward(pCode->pText, 0, '\n', pCode->focusStartRow);
	}
}

static void CodeBoxIncrementFocusRow(CodeBox* pCode, int increment)
{
	pCode->focusStartRow -= increment;
	pCode->focusStartRow = MAX(pCode->focusStartRow, 0);
	pCode->focusStartRow = MIN(pCode->focusStartRow, pCode->textRowCount);
	pCode->focusStartRowIndex = TextFindCharSkipForward(pCode->pText, 0, '\n', pCode->focusStartRow);
}

/* Focus on a given character index. */
static inline void CodeBoxFocusIndex(CodeBox* pCode, int toIndex)
{
	int toRow = CodeBoxIndexRow(pCode, toIndex);
	CodeBoxFocusRow(pCode, toRow);
}

/* Focus on Mark */
static inline void CodeBoxFocusMark(CodeBox* pCode)
{
	CodeBoxFocusRow(pCode, pCode->mark.row);
}

/* Update Mark Index */
static void CodeSetMarkIndex(CodeBox* pCode, int newMarkIndex)
{
	pCode->mark.index = newMarkIndex;
	pCode->mark.row   = CodeBoxIndexRow(pCode, newMarkIndex);
	pCode->mark.col   = CodeBoxIndexCol(pCode, newMarkIndex);
	assert(pCode->mark.index >= 0);
	assert(pCode->mark.index <= pCode->textCount);
	assert(pCode->mark.row   >= 0);
	assert(pCode->mark.row   <= pCode->textRowCount);
	assert(pCode->mark.col   >= 0);
}

static void CodeSetMarkRow(CodeBox* pCode, int newMarkRow)
{
	const char* pText = pCode->pText;
	pCode->mark.row   = newMarkRow;
	int markRowStartIndex = TextFindCharSkipForward(pText, 0, '\n', newMarkRow);
	int markRowEndIndex   = TextFindCharForward(pText, markRowStartIndex, '\n');
	pCode->mark.index = MIN(markRowStartIndex + pCode->mark.col, markRowEndIndex);
}

static void CodeSyncMarkToCaret(CodeBox* pCode, u8 iCaret)
{
	memcpy(&pCode->mark, pCode->pCarets + iCaret, sizeof(CodePos));
}

/* Sync Current Mark To Specified Caret  */
static void CodeSyncCaretToMark(CodeBox* pCode, u8 iCaret)
{
	memcpy(pCode->pCarets + iCaret, &pCode->mark, sizeof(CodePos));
}

/* Sync Specified Caret to Current Mark Row */
static void CodeSyncCaretToMarkRow(CodeBox* pCode, u8 iCaret)
{
	CodePos mark = pCode->mark;
	CodeRow row  = CodeRowFromIndex(pCode->pText, mark.index);
	int newCol = MIN(row.endIndex - row.startIndex, mark.col);
	int newIndex = row.startIndex + newCol;
	CodePos* pCaret = pCode->pCarets + iCaret;
	pCaret->index = newIndex;
	pCaret->col   = newCol;
	pCaret->row   = mark.row;
	pCode->mark.index = newIndex;
}

static void CodeBoxInsertNewlineAtCaret(CodeBox* pCode, CodePos caret)
{
	memmove(pCode->pText + caret.index + 1,   pCode->pText + caret.index,   (pCode->textCount - caret.index - 1)  * sizeof(char));
	pCode->dirty = true;
	pCode->pText[caret.index] = '\n';
	pCode->textCount++;
	pCode->textRowCount++;

	// TODO this needs to run incrementally
	CodeBoxProcessMeta(pCode);
}

static void CodeBoxInsertCharAtCaret(CodeBox* pCode, CodePos caret, char c)
{
	memmove(pCode->pText + caret.index + 1, pCode->pText + caret.index, pCode->textCount - caret.index - 1);
	pCode->dirty = true;
	pCode->pText[caret.index] = c;
	pCode->textCount++;

	// TODO this needs to run incrementally
	CodeBoxProcessMeta(pCode);
}

static void CodeBoxDeleteNewlineAtCaret(CodeBox* pCode, CodePos caret)
{
	if (pCode->textCount == 0) return;
	memmove(pCode->pText + caret.index-1, pCode->pText + caret.index, (pCode->textCount - caret.index)  * sizeof(char));
	pCode->dirty = true;
	pCode->textCount--;
	pCode->textRowCount--;

	// TODO this needs to run incrementally
	CodeBoxProcessMeta(pCode);
}

static void CodeBoxDeleteCharAtCaret(CodeBox* pCode, CodePos caret)
{
	if (pCode->textCount == 0) return;
	if (caret.index == 0) return;
	if (pCode->pText[caret.index - 1] == '\n') {
		// TODO don't like this?
		CodeBoxDeleteNewlineAtCaret(pCode, caret);
		return;
	}

	memmove(pCode->pText + caret.index - 1, pCode->pText + caret.index, pCode->textCount - caret.index);
	pCode->textCount--;

	// TODO this needs to run incrementally
	CodeBoxProcessMeta(pCode);
}

static void CommandFinish(CodeBox* pCode, Command* pCommand)
{
	CodeSetMarkIndex(pCode, pCommand->scanFoundIndex);
	CodeBoxFocusRow(pCode, pCode->pCarets[0].row);
	pCommand->scanFoundIndex  = 0;
	pCommand->bufferCount     = 0;
	pCommand->enabled         = false;
	pCommand->toggled         = false;
	pCommand->firstKeyPressed = false;
}

void PrintU16Binary(u16 value) {
	for (int i = 15; i >= 0; i--) {
		putchar((value & (1 << i)) ? '1' : '0');
		if (i % 4 == 0) putchar(' ');
	}
	putchar('\n');
}

/*
 * rayDE Application
 */
static struct {
	Vector2 windowSize;
	Font    font;
	CodeBox codeboxes[10];
} rayde = {
	.windowSize.x = DEFAULT_WIDTH,
	.windowSize.y = DEFAULT_HEIGHT,
};

int main(void)
{
	#define CONSTRUCT_TOK_DEF_FRIE(_tok) REQUIRE(ConstructFrie(NARRAY(_tok##_DEFS), _tok##_DEFS, NARRAY(_tok##_FRIE), _tok##_FRIE));
	#define CONSTRUCT_TOK_DEF_FRIE_ALL(_defs) _defs(CONSTRUCT_TOK_DEF_FRIE)

		CONSTRUCT_TOK_DEF_FRIE_ALL(DEF_TOK_ALL_DEFINITIONS)

	#undef CONSTRUCT_TOK_DEF_FRIE
	#undef CONSTRUCT_TOK_DEF_FRIE_ALL

	/* Config */
	SetTraceLogLevel(LOG_ALL);
	SetConfigFlags(FLAG_VSYNC_HINT | FLAG_WINDOW_RESIZABLE | FLAG_WINDOW_HIGHDPI);
	EnableEventWaiting();
	InitWindow(rayde.windowSize.x, rayde.windowSize.y, "rayDE");

	/* Font */
	int codepointCount = 0;
	int *codepoints = LoadCodepoints(availableChars, &codepointCount);
	rayde.font = LoadFontEx("resources/JetBrainsMono-Regular.ttf", fontSize, codepoints, codepointCount);
	SetTextureFilter(rayde.font.texture, TEXTURE_FILTER_BILINEAR);
	SetTextLineSpacing(0);

	/* State */
	CodeBox* pCode = &rayde.codeboxes[0];

	struct {
		bool mouseMarkActive;
		Vector2 mousePos;
		float scrollMouse;
		float scrollMouseMultiplier;
		bool  lMouse;
		bool  Shift;
		bool  Ctrl;
		bool  CtrlAlt;
		bool  Alt;
		bool  AltCtrl;
		u32   modifierCombination;
	} input; ZERO(&input);

	Command command; ZERO(&command);

	bool mouseOnText  = false;
	int framesCounter = 0;
	u16 currentKey    = 0; // todo move into input
	u16 priorKey      = 0;

	#define CODEBOX_ROW_CAPACITY 1024
	#define CODEBOX_CARET_CAPACITY 128
	pCode->pCarets    = XCALLOC(CODEBOX_CARET_CAPACITY, CodePos);
	pCode->caretCount = 1;
	CodeBoxSetRect(pCode, (Rectangle){ 0, 0, rayde.windowSize.x, rayde.windowSize.y });

	/* File Load */
	{
		pCode->pText     = XCALLOC(TEXT_BUFFER_CAPACITY, char);
		pCode->pTextMeta = XCALLOC(TEXT_BUFFER_CAPACITY, TextMeta);

		pCode->pTextPath = "./src/main.c";
		char* loadedFile = LoadFileText(pCode->pTextPath);
		int index = 0;
		int rowIndex = 0;
		int startIndex = 0;
		while (loadedFile[index] != '\0') {
			if (loadedFile[index] == '\n') {
				startIndex = index + 1;
				rowIndex++;
			}
			index++;
		}
		pCode->textRowCount = rowIndex;
		pCode->textCount = index;
		LOG("Loaded Buffer Size %d\n", pCode->textCount);
		ASSERTMSG(pCode->textCount < TEXT_BUFFER_CAPACITY, "Loaded buffer size %d bigger than capacity %d!", pCode->textCount, TEXT_BUFFER_CAPACITY);

		memcpy(pCode->pText, loadedFile, pCode->textCount + 1);
		free(loadedFile);

		REQUIRE(CodeBoxProcessMeta(pCode));
	}

/*
 * Main Loop
 */
LoopBegin:

	float frameTime = GetFrameTime();
	framesCounter++;

	if (IsWindowResized() && !IsWindowFullscreen())
	{
		rayde.windowSize.x = GetScreenWidth();
		rayde.windowSize.y = GetScreenHeight();
		CodeBoxSetRect(pCode, (Rectangle){ 0, 0, rayde.windowSize.x, rayde.windowSize.y });
	}

	/* Input Read */
	{
		SetMouseCursor(mouseOnText ? MOUSE_CURSOR_IBEAM : MOUSE_CURSOR_DEFAULT);

		Vector2 newMousePos = GetMousePosition();
		if (input.mousePos.x != newMousePos.x || input.mousePos.y != newMousePos.y) {
			input.mouseMarkActive = true;
			input.mousePos = newMousePos;
		}
		input.scrollMouse = GetMouseWheelMove() * 2;
		input.lMouse      = IsMouseButtonPressed(MOUSE_BUTTON_LEFT);

		input.Shift   = IsKeyDown(KEY_LEFT_SHIFT)   | IsKeyDown(KEY_RIGHT_SHIFT);
		bool altDown  = IsKeyDown(KEY_LEFT_ALT)     | IsKeyDown(KEY_RIGHT_ALT);
		bool ctrlDown = IsKeyDown(KEY_LEFT_CONTROL) | IsKeyDown(KEY_RIGHT_CONTROL);
		input.AltCtrl = input.Alt  && altDown  && ctrlDown && !input.CtrlAlt;
		input.CtrlAlt = input.Ctrl && ctrlDown && altDown  && !input.AltCtrl;
		input.Alt  = altDown;
		input.Ctrl = ctrlDown;

		input.modifierCombination =
			(input.Shift   ? MASK_SHIFT    : 0) |
			(input.Alt     ? MASK_ALT      : 0) |
			(input.Ctrl    ? MASK_CTRL     : 0) |
			(input.AltCtrl ? MASK_ALT_CTRL : 0) |
			(input.CtrlAlt ? MASK_CTRL_ALT : 0);

		currentKey = GetKeyPressed();
		if (currentKey == 0 && IsKeyPressedRepeat(priorKey))
			currentKey = priorKey;

		CodeBoxIncrementFocusRow(pCode, input.scrollMouse);
	}

	/* Command Finish */
	if (command.enabled) {

		// Released!
		if (currentKey == 0 && input.modifierCombination == 0) {

			// Toggle Command On!
			if (!command.toggled && !command.firstKeyPressed) {
				LOG("Command Toggle On\n");
				command.toggled = true;
			}

			// Scanned? Jump to immediately.
			if (command.scanFoundIndex > 0 && !command.toggled) {
				CommandFinish(pCode, &command);
				LOG("Command Quick Scan Finish\n");
			}

		}

	}

	if (command.toggled) {

		// LOG("Command Toggled\n");
		input.Alt = true;
		input.modifierCombination =
			(input.Shift ? MASK_SHIFT : 0) |
			(input.Alt   ? MASK_ALT   : 0) |
			(input.Ctrl  ? MASK_CTRL  : 0);

	}

	/*
	 * Input Process
	 */
	{
	#define SHIFT   MASK_SHIFT
	#define CTRL    MASK_CTRL
	#define ALT     MASK_ALT
	#define CTRLALT MASK_CTRL | MASK_ALT  | MASK_CTRL_ALT
	#define ALTCTRL MASK_ALT  | MASK_CTRL | MASK_ALT_CTRL

		// TODO pull this into struct function to be used solely for text input
		int iCaret = 0;
		CodePos  mark   =  pCode->mark;
		CodePos *pMark  = &pCode->mark;
		CodePos  caret  =  pCode->pCarets[iCaret];
		CodePos *pCaret = &pCode->pCarets[iCaret];
		char*    pText  =  pCode->pText;
		while (currentKey > 0) {
			ASSERTMSG(currentKey < MASK_KEYS, "Input key %d should not be greater than %d!", currentKey, MASK_KEYS);
			int modifiedKey = currentKey;
			switch (currentKey | input.modifierCombination) 
			{
				/* Move Left One Char */
				case KEY_LEFT:
				case KEY_J | CTRL: {
					input.mouseMarkActive = false;
					if (caret.index <= 0) break;
					CodeSetMarkIndex(pCode, mark.index - 1);
					CodeSyncCaretToMark(pCode, 0);
					break;
				}
				/* Move Left One Word */
				case KEY_LEFT | CTRL:
				case KEY_J    | CTRLALT: {
					input.mouseMarkActive = false;
					if (caret.index <= 0) break;
					int newIndex = CARET_INVALID;
					switch(pText[mark.index - 1]){
						case ' ':  newIndex = TextNegateFindCharBackward(pText, mark.index - 1, ' ');  break;
						case '\n': newIndex = TextNegateFindCharBackward(pText, mark.index - 1, '\n'); break;
						default:   newIndex = TextFindCharsBackward(pText, mark.index - 1, " \n");     break;
					}
					if (newIndex != CARET_INVALID) {
						CodeSetMarkIndex(pCode, newIndex + 1);
						CodeSyncCaretToMarkRow(pCode, 0);
						CodeBoxFocusMark(pCode);
					}
					break;
				}
				/* Move Right One Char */
				case KEY_RIGHT:
				case KEY_L | CTRL: {
					input.mouseMarkActive = false;
					if (caret.index >= pCode->textCount) break;
					CodeSetMarkIndex(pCode, mark.index + 1);
					CodeSyncCaretToMark(pCode, 0);
					break;
				}
				/* Move Right One Word */
				case KEY_RIGHT | CTRL:
				case KEY_L     | CTRLALT: {
					input.mouseMarkActive = false;
					if (caret.index >= pCode->textCount) break;
					int newIndex = CARET_INVALID;
					switch(pText[mark.index]){
						case ' ' : newIndex = TextNegateFindCharForward(pText, mark.index, ' ');  break;
						case '\t': newIndex = TextNegateFindCharForward(pText, mark.index, '\t');  break;
						case '\n': newIndex = TextNegateFindCharForward(pText, mark.index, '\n'); break;
						default:   newIndex = TextFindCharsForward(pText, mark.index, " \n");     break;
					}
					if (newIndex != CARET_INVALID) {
						CodeSetMarkIndex(pCode, newIndex);
						CodeSyncCaretToMarkRow(pCode, 0);
						CodeBoxFocusMark(pCode);
					}
					break;
				}
				/* Move Up One Char */
				case KEY_UP:
				case KEY_I | CTRL:{
					input.mouseMarkActive = false;
					CodeSetMarkRow(pCode, mark.row - 1);
					CodeSyncCaretToMarkRow(pCode, 0);
					CodeBoxFocusMark(pCode);
					break;
				}
				/* Move Up One Word */
				case KEY_UP | CTRL:
				case KEY_I  | CTRLALT: {
					input.mouseMarkActive = false;
					int startIndex      = pText[mark.index] == '\n' ? mark.index - endCharLength : mark.index;
					int blockStartIndex = TextFindTextBackward(pText, startIndex, "\n\n");
					int blockEndIndex   = TextNegateFindCharBackward(pText, blockStartIndex, '\n');
					int newCaretIndex   = blockEndIndex + 1;
					CodeSetMarkIndex(pCode, newCaretIndex);
					CodeSyncCaretToMarkRow(pCode, 0);
					CodeBoxFocusMark(pCode);
					break;
				}
				/* Move Down One Char */
				case KEY_DOWN:
				case KEY_K | CTRL: {
					input.mouseMarkActive = false;
					CodeSetMarkRow(pCode, mark.row + 1);
					CodeSyncCaretToMarkRow(pCode, 0);
					CodeBoxFocusMark(pCode);
					break;
				}
				/* Move Down One Word */
				case KEY_DOWN | CTRL:
				case KEY_K    | CTRLALT: {
					input.mouseMarkActive = false;
					// Search"\n\n" to find where there is a new line gap
					int blockEndIndex   = TextFindTextForward(pText, mark.index, "\n\n");
					int blockStartIndex = TextNegateFindCharForward(pText, blockEndIndex, '\n');
					blockStartIndex     = TextNegateFindCharForward(pText, blockStartIndex, ' ');
					blockStartIndex     = TextNegateFindCharForward(pText, blockStartIndex, '\t');
					int newCaretIndex   = blockStartIndex;
					CodeSetMarkIndex(pCode, newCaretIndex);
					CodeSyncCaretToMarkRow(pCode, 0);
					CodeBoxFocusMark(pCode);
					break;
				}
				/* Command Keys */
				// case ALT | KEY_RIGHT_ALT:
				// case ALT | KEY_LEFT_ALT:
				// 	if (!command.enabled) {
				// 		LOG("Command Begin\n");
				// 		command.enabled = true;
				// 		command.scanFoundIndex = pCode->pActiveCaret->index;
				// 		LOG("%d\n", command.scanFoundIndex);
				// 		break;
				// 	}

				// 	if (command.enabled && command.toggled ) {
				// 		LOG("Command Toggle Off\n");
				// 		command.enabled = false;
				// 		command.toggled = false;
				// 		break;
				// 	}

				// 	break;

				// case ALT | CTRL | KEY_LEFT_CONTROL:
				// 	break;

				// case ALT | KEY_ENTER:
				// 	if (!command.enabled)
				// 		break;

				// 	LOG("Command Finish\n");
				// 	CommandFinish(pCode, &command);

				// 	break;

				// case ALT | SHIFT | KEY_TAB:

				// 	break;

				// case ALT | KEY_TAB:
				// 	if (!command.enabled)
				// 		break;

				// 	LOG("%d %d\n", pCode->pActiveCaret->index, command.scanFoundIndex);

				// 	command.scanFoundIndex = TextFindTextForward(pCode->pText, command.scanFoundIndex + 1, command.pText);
				// 	if (command.scanFoundIndex > 0) {
				// 		int scanFoundLine = TextCountCharForward(pCode->pText, pCode->pActiveCaret->index, command.scanFoundIndex, '\n') + pCode->pActiveCaret->row;
				// 		CodeBoxFocusRow(pCode, scanFoundLine);
				// 		LOG("%d \n", scanFoundLine);
				// 	}

				// 	break;

				// case '`'  | ALT:
				// case '-'  | ALT:
				// case '='  | ALT:
				// case '['  | ALT:
				// case ']'  | ALT:
				// case '\\' | ALT:
				// case ';'  | ALT:
				// case '\'' | ALT:
				// case ','  | ALT:
				// case '.'  | ALT:
				// case '/'  | ALT:

				// case (ALT | '0') ... (ALT | '9'):
				// 	goto UpdateCommandKey;

				// case '1'  | ALT | SHIFT: modifiedKey = '!'; goto UpdateCommandKey;
				// case '2'  | ALT | SHIFT: modifiedKey = '@'; goto UpdateCommandKey;
				// case '3'  | ALT | SHIFT: modifiedKey = '#'; goto UpdateCommandKey;
				// case '4'  | ALT | SHIFT: modifiedKey = '$'; goto UpdateCommandKey;
				// case '5'  | ALT | SHIFT: modifiedKey = '%'; goto UpdateCommandKey;
				// case '6'  | ALT | SHIFT: modifiedKey = '^'; goto UpdateCommandKey;
				// case '7'  | ALT | SHIFT: modifiedKey = '&'; goto UpdateCommandKey;
				// case '8'  | ALT | SHIFT: modifiedKey = '*'; goto UpdateCommandKey;
				// case '9'  | ALT | SHIFT: modifiedKey = '('; goto UpdateCommandKey;
				// case '0'  | ALT | SHIFT: modifiedKey = ')'; goto UpdateCommandKey;
				// case '`'  | ALT | SHIFT: modifiedKey = '~'; goto UpdateCommandKey;
				// case '-'  | ALT | SHIFT: modifiedKey = '_'; goto UpdateCommandKey;
				// case '='  | ALT | SHIFT: modifiedKey = '+'; goto UpdateCommandKey;
				// case '['  | ALT | SHIFT: modifiedKey = '{'; goto UpdateCommandKey;
				// case ']'  | ALT | SHIFT: modifiedKey = '}'; goto UpdateCommandKey;
				// case '\\' | ALT | SHIFT: modifiedKey = '|'; goto UpdateCommandKey;
				// case ';'  | ALT | SHIFT: modifiedKey = ':'; goto UpdateCommandKey;
				// case '\'' | ALT | SHIFT: modifiedKey = '"'; goto UpdateCommandKey;
				// case ','  | ALT | SHIFT: modifiedKey = '<'; goto UpdateCommandKey;
				// case '.'  | ALT | SHIFT: modifiedKey = '>'; goto UpdateCommandKey;
				// case '/'  | ALT | SHIFT: modifiedKey = '?'; goto UpdateCommandKey;

				// case (ALT | 'A') ... (ALT | 'Z'):
				// 	modifiedKey = TO_LOWER_C(currentKey);
				// 	goto UpdateCommandKey;

				// case (ALT | SHIFT | 'A') ... (ALT | SHIFT | 'Z'):
				// 	goto UpdateCommandKey;

				// case ALT | KEY_BACKSPACE:
				// case ALT | SHIFT | KEY_BACKSPACE:
				// 	command.firstKeyPressed = true;
				// 	if (command.bufferCount > 0) command.bufferCount--;
				// 	goto UpdateCommandScan;

				// case ALT | CTRL | KEY_BACKSPACE:
				// case ALT | CTRL | SHIFT | KEY_BACKSPACE:
				// case ALT | KEY_DELETE:
				// 	command.firstKeyPressed = true;
				// 	command.bufferCount = 0;
				// 	command.scanFoundIndex = 0;
				// 	command.buffer[command.bufferCount] = '\0';
				// 	break;

				UpdateCommandKey: {
					if (!command.firstKeyPressed) command.firstKeyPressed = true;
					command.buffer[command.bufferCount++] = modifiedKey;
					command.buffer[command.bufferCount] = '\0';
				}
				UpdateCommandScan: {
					LOG("%d\n", command.scanFoundIndex);
					command.scanFoundIndex = TextFindTextForward(pText, mark.index, command.buffer);
					break;
				}
				/* Utility Keys */
				case CTRL | KEY_S: {
					LOG("Saving: %s", pCode->pTextPath);
					SaveFileText(pCode->pTextPath, pCode->pText);
					break;
				}
				/* Delete Char */
				case KEY_DELETE: {
					CodeBoxDeleteCharAtCaret(pCode, (CodePos){ .col = caret.col, .row = caret.row, .index = caret.index+1 });
					break;
				}
				case KEY_BACKSPACE: {
					CodeBoxDeleteCharAtCaret(pCode, caret);
					CodeSetMarkIndex(pCode, mark.index - 1);
					CodeSyncCaretToMark(pCode, 0);
					break;
				}
				/* Insert Char */
				case KEY_ENTER: {
					CodeBoxInsertNewlineAtCaret(pCode, caret);
					CodeSetMarkIndex(pCode, mark.index + 1);
					CodeSyncCaretToMark(pCode, 0);
					break;
				}
				case KEY_SPACE: modifiedKey = ' ';  goto InsertChar;
				case KEY_TAB:   modifiedKey = '\t'; goto InsertChar;
				case KEY_KP_0 ... KEY_KP_9: modifiedKey = '0' + (currentKey - KEY_KP_0); goto InsertChar;
				case '1'  | SHIFT: modifiedKey = '!'; goto InsertChar;
				case '2'  | SHIFT: modifiedKey = '@'; goto InsertChar;
				case '3'  | SHIFT: modifiedKey = '#'; goto InsertChar;
				case '4'  | SHIFT: modifiedKey = '$'; goto InsertChar;
				case '5'  | SHIFT: modifiedKey = '%'; goto InsertChar;
				case '6'  | SHIFT: modifiedKey = '^'; goto InsertChar;
				case '7'  | SHIFT: modifiedKey = '&'; goto InsertChar;
				case '8'  | SHIFT: modifiedKey = '*'; goto InsertChar;
				case '9'  | SHIFT: modifiedKey = '('; goto InsertChar;
				case '0'  | SHIFT: modifiedKey = ')'; goto InsertChar;
				case '`'  | SHIFT: modifiedKey = '~'; goto InsertChar;
				case '-'  | SHIFT: modifiedKey = '_'; goto InsertChar;
				case '='  | SHIFT: modifiedKey = '+'; goto InsertChar;
				case '['  | SHIFT: modifiedKey = '{'; goto InsertChar;
				case ']'  | SHIFT: modifiedKey = '}'; goto InsertChar;
				case '\\' | SHIFT: modifiedKey = '|'; goto InsertChar;
				case ';'  | SHIFT: modifiedKey = ':'; goto InsertChar;
				case '\'' | SHIFT: modifiedKey = '"'; goto InsertChar;
				case ','  | SHIFT: modifiedKey = '<'; goto InsertChar;
				case '.'  | SHIFT: modifiedKey = '>'; goto InsertChar;
				case '/'  | SHIFT: modifiedKey = '?'; goto InsertChar;
				case 'A' ... 'Z': modifiedKey = 'a' + (currentKey - KEY_A); goto InsertChar;
				case 'A' | SHIFT ... 'Z' | SHIFT:
				case '0' ... '9':
				case '`' :
				case '-' :
				case '=' :
				case '[' :
				case ']' :
				case '\\':
				case ';' :
				case '\'':
				case ',' :
				case '.' :
				case '/' : modifiedKey = currentKey;
				InsertChar: {
					CodeBoxInsertCharAtCaret(pCode, caret, modifiedKey);
					CodeSetMarkIndex(pCode, mark.index + 1);
					CodeSyncCaretToMark(pCode, 0);
					break;
				}
				/* Jump Forward To Char */
				case KEY_ENTER    | ALT: modifiedKey = '\n'; goto JumpForwardToChar;
				case '1'  | SHIFT | ALT: modifiedKey = '!';  goto JumpForwardToChar;
				case '2'  | SHIFT | ALT: modifiedKey = '@';  goto JumpForwardToChar;
				case '3'  | SHIFT | ALT: modifiedKey = '#';  goto JumpForwardToChar;
				case '4'  | SHIFT | ALT: modifiedKey = '$';  goto JumpForwardToChar;
				case '5'  | SHIFT | ALT: modifiedKey = '%';  goto JumpForwardToChar;
				case '6'  | SHIFT | ALT: modifiedKey = '^';  goto JumpForwardToChar;
				case '7'  | SHIFT | ALT: modifiedKey = '&';  goto JumpForwardToChar;
				case '8'  | SHIFT | ALT: modifiedKey = '*';  goto JumpForwardToChar;
				case '9'  | SHIFT | ALT: modifiedKey = '(';  goto JumpForwardToChar;
				case '0'  | SHIFT | ALT: modifiedKey = ')';  goto JumpForwardToChar;
				case '`'  | SHIFT | ALT: modifiedKey = '~';  goto JumpForwardToChar;
				case '-'  | SHIFT | ALT: modifiedKey = '_';  goto JumpForwardToChar;
				case '='  | SHIFT | ALT: modifiedKey = '+';  goto JumpForwardToChar;
				case '['  | SHIFT | ALT: modifiedKey = '{';  goto JumpForwardToChar;
				case ']'  | SHIFT | ALT: modifiedKey = '}';  goto JumpForwardToChar;
				case '\\' | SHIFT | ALT: modifiedKey = '|';  goto JumpForwardToChar;
				case ';'  | SHIFT | ALT: modifiedKey = ':';  goto JumpForwardToChar;
				case '\'' | SHIFT | ALT: modifiedKey = '"';  goto JumpForwardToChar;
				case ','  | SHIFT | ALT: modifiedKey = '<';  goto JumpForwardToChar;
				case '.'  | SHIFT | ALT: modifiedKey = '>';  goto JumpForwardToChar;
				case '/'  | SHIFT | ALT: modifiedKey = '?';  goto JumpForwardToChar;
				case 'A'  | ALT ... 'Z' | ALT: modifiedKey = 'a' + (currentKey - KEY_A); goto JumpForwardToChar;
				case 'A'  | SHIFT | ALT ... 'Z' | SHIFT | ALT:
				case '0'  | ALT ... '9' | ALT: 
				case '`'  | ALT:                
				case '-'  | ALT:
				case '='  | ALT:
				case '['  | ALT:
				case ']'  | ALT:
				case '\\' | ALT:
				case ';'  | ALT:
				case '\'' | ALT:
				case ','  | ALT:
				case '.'  | ALT:
				case '/'  | ALT: modifiedKey = currentKey;
				JumpForwardToChar: {
					input.mouseMarkActive = false;
					if (caret.index >= pCode->textCount) break;
					int newIndex = TextFindCharForward(pText, mark.index+1, modifiedKey);
					CodeSetMarkIndex(pCode, newIndex);
					CodeSyncCaretToMarkRow(pCode, 0);
					CodeBoxFocusMark(pCode);
					break;
				}
				/* Jump Backward To Char */
				case KEY_ENTER    | ALTCTRL: modifiedKey = '\n'; goto JumpBackwardToChar;
				case '1'  | SHIFT | ALTCTRL: modifiedKey = '!';  goto JumpBackwardToChar;
				case '2'  | SHIFT | ALTCTRL: modifiedKey = '@';  goto JumpBackwardToChar;
				case '3'  | SHIFT | ALTCTRL: modifiedKey = '#';  goto JumpBackwardToChar;
				case '4'  | SHIFT | ALTCTRL: modifiedKey = '$';  goto JumpBackwardToChar;
				case '5'  | SHIFT | ALTCTRL: modifiedKey = '%';  goto JumpBackwardToChar;
				case '6'  | SHIFT | ALTCTRL: modifiedKey = '^';  goto JumpBackwardToChar;
				case '7'  | SHIFT | ALTCTRL: modifiedKey = '&';  goto JumpBackwardToChar;
				case '8'  | SHIFT | ALTCTRL: modifiedKey = '*';  goto JumpBackwardToChar;
				case '9'  | SHIFT | ALTCTRL: modifiedKey = '(';  goto JumpBackwardToChar;
				case '0'  | SHIFT | ALTCTRL: modifiedKey = ')';  goto JumpBackwardToChar;
				case '`'  | SHIFT | ALTCTRL: modifiedKey = '~';  goto JumpBackwardToChar;
				case '-'  | SHIFT | ALTCTRL: modifiedKey = '_';  goto JumpBackwardToChar;
				case '='  | SHIFT | ALTCTRL: modifiedKey = '+';  goto JumpBackwardToChar;
				case '['  | SHIFT | ALTCTRL: modifiedKey = '{';  goto JumpBackwardToChar;
				case ']'  | SHIFT | ALTCTRL: modifiedKey = '}';  goto JumpBackwardToChar;
				case '\\' | SHIFT | ALTCTRL: modifiedKey = '|';  goto JumpBackwardToChar;
				case ';'  | SHIFT | ALTCTRL: modifiedKey = ':';  goto JumpBackwardToChar;
				case '\'' | SHIFT | ALTCTRL: modifiedKey = '"';  goto JumpBackwardToChar;
				case ','  | SHIFT | ALTCTRL: modifiedKey = '<';  goto JumpBackwardToChar;
				case '.'  | SHIFT | ALTCTRL: modifiedKey = '>';  goto JumpBackwardToChar;
				case '/'  | SHIFT | ALTCTRL: modifiedKey = '?';  goto JumpBackwardToChar;
				case 'A'  | ALTCTRL ... 'Z' | ALTCTRL: modifiedKey = 'a' + (currentKey - KEY_A); goto JumpBackwardToChar;
				case 'A'  | SHIFT | ALTCTRL ... 'Z' | SHIFT | ALTCTRL:
				case '0'  | ALTCTRL ... '9' | ALTCTRL: 
				case '`'  | ALTCTRL:                
				case '-'  | ALTCTRL:
				case '='  | ALTCTRL:
				case '['  | ALTCTRL:
				case ']'  | ALTCTRL:
				case '\\' | ALTCTRL:
				case ';'  | ALTCTRL:
				case '\'' | ALTCTRL:
				case ','  | ALTCTRL:
				case '.'  | ALTCTRL:
				case '/'  | ALTCTRL: modifiedKey = currentKey;
				JumpBackwardToChar: {
					input.mouseMarkActive = false;
					if (caret.index <= 0) break;
					int newIndex = TextFindCharBackward(pText, mark.index-2, modifiedKey) + 1;
					CodeSetMarkIndex(pCode, newIndex);
					CodeSyncCaretToMarkRow(pCode, 0);
					CodeBoxFocusMark(pCode);
					break;
				}
				default: break;
			}

			priorKey = currentKey;
			currentKey = GetKeyPressed();
		}

	#undef SHIFT
	#undef CTRL
	#undef ALT
	#undef CTRLALT
	#undef ALTCTRL
	}

	/*
	 * Render CodeBox
	 */
	BeginDrawing();
	{
		/* window */
		ClearBackground(RAYWHITE);

		/* Background Fill */
		#define LEFT_MARGIN_CAPACITY 16
		#define LEFT_MARGIN_SIZE   6
		#define RIGHT_MARGIN_SIZE  1
		#define BOTTOM_MARGIN_SIZE 2

		const Rectangle boxRect = pCode->rect;
		const Rectangle statusMarginRect = {
			boxRect.x,     boxRect.height - (fontYSpacing*BOTTOM_MARGIN_SIZE),
			boxRect.width, fontYSpacing
		};
		const Rectangle commandMarginRect = {
			boxRect.x,     statusMarginRect.y + statusMarginRect.height,
			boxRect.width, (fontYSpacing*BOTTOM_MARGIN_SIZE) - statusMarginRect.height
		};
		const Rectangle bottomMarginRect = {
			boxRect.x,     statusMarginRect.y,
			boxRect.width, statusMarginRect.height + commandMarginRect.height,
		};
		const Rectangle leftMarginRect = {
			boxRect.x,                       boxRect.y,
			fontXSpacing * LEFT_MARGIN_SIZE, boxRect.height - bottomMarginRect.height
		};
		const Rectangle rightMarginRect = {
			boxRect.width - (fontXSpacing*RIGHT_MARGIN_SIZE), boxRect.y,
			fontXSpacing * RIGHT_MARGIN_SIZE,                 boxRect.height - bottomMarginRect.height
		};
		const Rectangle codeRect = {
			boxRect.x + leftMarginRect.width,                             boxRect.y,
			boxRect.width - leftMarginRect.width - rightMarginRect.width, boxRect.height - bottomMarginRect.height
		};

		DrawRectangleRec(leftMarginRect, COLOR_BACKGROUND_DIM);
		DrawRectangleRec(codeRect, COLOR_BACKGROUND);

		/* Draw Text */
		const bool    boxHovering = CheckCollisionPointRec(input.mousePos, codeRect);
		const Vector2 hoverBoxPos = GetWorldToBoxLocal(input.mousePos, codeRect);

		const int       count = pCode->textCount;
		const char*     pText = pCode->pText;
		const TextMeta* pMeta = pCode->pTextMeta;
		const int boxRowCount = pCode->boxRowCount;
		const int boxColCount = pCode->boxColCount;
		const int focusStartRow = pCode->focusStartRow;
		const int focusStartRowIndex = pCode->focusStartRowIndex;

		const int fontXSpacingHalf = (fontXSpacing / 2);
		const int fontYSpacingHalf = (fontYSpacing / 2);

		const CodePos  mainCaret = pCode->pCarets[0];
		const char     caretChar = pText[mainCaret.index];
		const TextMeta caretMeta = pMeta[mainCaret.index];
		const CodeRow  caretRow  = CodeRowFromIndex(pText, mainCaret.index);

		Vector2 scanFoundPosition = { -1, -1}; // TODO compute deterministically

		/* Mark Mouse Input */
		bool    markPress = false;
		CodePos mark      = pCode->mark;
		if (boxHovering && input.mouseMarkActive) {
			int iHoverBoxCol = hoverBoxPos.x / fontXSpacing;
			int iHoverBoxRow = hoverBoxPos.y / fontYSpacing;
			mark.col = iHoverBoxCol;
			mark.row = focusStartRow + iHoverBoxRow;
			int markRowStartIndex = TextFindCharSkipForward(pText, focusStartRowIndex, '\n', iHoverBoxRow);
			int markRowEndIndex   = TextFindCharForward(pText, markRowStartIndex, '\n');
			mark.index = MIN(markRowStartIndex + iHoverBoxCol, markRowEndIndex);
			markPress = input.lMouse;
		}

		/* Mark Highlight */
		{
			TextMeta markMeta = pMeta[mark.index];
			int iLScopeRow = mark.row;
			int iRScopeRow = mark.row;
			int iLScope = mark.index;
			int iRScope = mark.index;

			switch (markMeta.tok.val)
			{
			#define SCOPE_COLOR_CASE(_forwardC, _backwardC, _level)\
				case _forwardC: {\
					while (pMeta[iRScope+1]._level != markMeta._level - 1 && iRScope++ < count)\
						if (pText[iRScope] == '\n') iRScopeRow++;\
					goto DrawHighlight;\
				}\
				case _backwardC: {\
					while (pMeta[iLScope-1]._level != markMeta._level - 1 && iLScope-- >= 0)\
						if (pText[iLScope] == '\n') iLScopeRow--;\
					goto DrawHighlight;\
				}

				SCOPE_COLOR_CASE('{', '}', braceLevel)
				SCOPE_COLOR_CASE('(', ')', parenLevel)
				SCOPE_COLOR_CASE('[', ']', bracketLevel)

			#undef SCOPE_COLOR_CASE

				default: {
					iLScope = mark.index - markMeta.tokOffset.iStart;
					iRScope = mark.index + markMeta.tokOffset.iEnd;
					// fallthrough
				}
				DrawHighlight: {
					int iStartChar = iLScope;
					for (int iHighlightRow = iLScopeRow, iHighlightBoxRow = iHighlightRow - focusStartRow;
							iHighlightRow <= iRScopeRow && iHighlightBoxRow <= boxRowCount;
							++iHighlightRow, iHighlightBoxRow = iHighlightRow - focusStartRow) {
						CodeRow highlightRow  = CodeRowFromIndex(pText, iStartChar);
						int iStartCol = iStartChar - highlightRow.startIndex;
						int iEndCol   = MIN(iRScope - highlightRow.startIndex, highlightRow.endIndex - highlightRow.startIndex);
						Vector2 startBoxPos = (Vector2){ (iStartCol   * fontXSpacing), (iHighlightBoxRow * fontYSpacing) };
						Vector2 endBoxPos   = (Vector2){ ((iEndCol+1) * fontXSpacing), (iHighlightBoxRow * fontYSpacing) };
						Vector2 startPos    = GetBoxLocalToWorld(startBoxPos, codeRect);
						Vector2 endPos      = GetBoxLocalToWorld(endBoxPos,   codeRect);
						Rectangle highlightRect = { startPos.x, startPos.y, endPos.x - startPos.x, fontYSpacing };
						DrawRectangleRec(highlightRect, COLOR_HOVER_HIGHLIGHT);
						iStartChar = highlightRow.endIndex+1;
					}
					break;
				}
			}

			if (markPress) {
				pCode->mark.index = mark.index;
				pCode->mark.col = mark.col;
				pCode->mark.row = mark.row;
				CodeSyncCaretToMarkRow(pCode, 0);
			}
		}

		/* Draw Text */
		int iText = focusStartRowIndex;
		for (int iRow = 0; iRow < boxRowCount; ++iRow) {
			Vector2 charPos = (Vector2){ leftMarginRect.x, leftMarginRect.y + (fontYSpacing * iRow) };
			static char leftMarginText[LEFT_MARGIN_CAPACITY];
			snprintf(leftMarginText, LEFT_MARGIN_CAPACITY, "%5d", iRow + focusStartRow),
			DrawTextEx(rayde.font, leftMarginText, charPos, fontSize, 0, COLOR_BACKGROUND_BRIGHT);

			char      currentChar = 0;
			Color     currentColor;
			TextMeta  currentMeta;
			for (int iCol = 0; iCol < boxColCount; ++iCol) {
				currentChar = pText[iText];
				currentMeta = pMeta[iText];
				charPos = (Vector2){ codeRect.x + (fontXSpacing * iCol), codeRect.y + (fontYSpacing * iRow) };

				char displayChar = currentChar;
				switch (currentMeta.tok.val)
				{
					case '\0': goto DrawTextEnd;

					/* Whitespace Symbols */
					case ' ':
					case '\t': {
						DrawTriangle((Vector2){charPos.x, charPos.y + fontYSpacingHalf}, (Vector2){charPos.x, charPos.y + fontYSpacingHalf + 1}, (Vector2){charPos.x + fontXSpacing, charPos.y + fontYSpacingHalf + 1}, TOK_KIND_COLOR[currentMeta.tok.kind]);
						iText++;
						goto DrawTextNextChar;
					}
					case '\r':
					case '\v':
					case '\f':
					case '\n': {
						DrawTriangle((Vector2){charPos.x+2, charPos.y + fontYSpacingHalf}, (Vector2){charPos.x+2, charPos.y + fontYSpacing}, (Vector2){charPos.x + fontXSpacing, charPos.y + fontYSpacingHalf}, TOK_KIND_COLOR[currentMeta.tok.kind]);
						iText++;
						goto DrawTextNextRow;
					}
					/* Scope Rainbow Highlight */
					case '[': case ']': {
						currentColor = TOK_SCOPE_COLORS[currentMeta.bracketLevel % NARRAY(TOK_SCOPE_COLORS)];
						goto DrawChar;
					}
					case '(': case ')': {
						currentColor = TOK_SCOPE_COLORS[currentMeta.parenLevel % NARRAY(TOK_SCOPE_COLORS)];
						goto DrawChar;
					}
					case '{': case '}': {
						currentColor = TOK_SCOPE_COLORS[currentMeta.braceLevel % NARRAY(TOK_SCOPE_COLORS)];
						goto DrawChar;
					}
					/* Highlight Sibling Tokens */
					default: {
						currentColor = TOK_KIND_COLOR[currentMeta.tok.kind];
						if (caretMeta.tok.val == currentMeta.tok.val  && currentMeta.tokOffset.iStart == 0 &&
							caretMeta.tok.kind != TOK_KIND_IDENTIFIER && caretMeta.tok.kind != TOK_KIND_NUMBER) {
							int iEndCol = iCol + currentMeta.tokOffset.iEnd;
							Vector2 startBoxPos = (Vector2){ (iCol        * fontXSpacing), (iRow * fontYSpacing) };
							Vector2 endBoxPos   = (Vector2){ ((iEndCol+1) * fontXSpacing), (iRow * fontYSpacing) };
							Vector2 startPos    = GetBoxLocalToWorld(startBoxPos, codeRect);
							Vector2 endPos      = GetBoxLocalToWorld(endBoxPos,   codeRect);
							Color     highlightColor = TOK_KIND_HIGHLIGHT_COLOR[currentMeta.tok.kind];
							Rectangle highlightRect  = { startPos.x, startPos.y, endPos.x - startPos.x, fontYSpacing };
							DrawRectangleRec(highlightRect, highlightColor);
						}
						// fallthrough
					}
					DrawChar: {
						int codePointSize;
						int codePoint = GetCodepoint(&displayChar, &codePointSize);
						DrawTextCodepoint(rayde.font, codePoint, charPos, fontSize, currentColor);
						iText++;
						break;
					}
				}

			DrawTextNextChar:
			} // iCol

		DrawTextNextRow:
			// If we are wrapping not on a newline, skip index to next new line so text doesn't wrap
			if (currentChar != '\n') iText = TextFindCharForward(pText, iText, '\n') + 1;

		} // iRow

	DrawTextEnd:

		/* Draw Margins */
		{
			DrawRectangleRec(rightMarginRect,   COLOR_BACKGROUND_DIM);
			DrawRectangleRec(statusMarginRect,  COLOR_BACKGROUND_BRIGHT);
			DrawRectangleRec(commandMarginRect, COLOR_BACKGROUND_DIM);
			DrawRectangleLines((int)codeRect.x, (int)codeRect.y, (int)codeRect.width, (int)codeRect.height, COLOR_BACKGROUND_BRIGHT);
		}

		/* Draw Mark */
		#define CARET_VERTICAL_EXTEND 2
		{
			Vector2 markBoxPos = (Vector2){ (mark.col * fontXSpacing), ((mark.row - focusStartRow) * fontYSpacing) };
			Vector2 markPos    = GetBoxLocalToWorld(markBoxPos, codeRect);
			DrawLineEx(
				(Vector2){markPos.x, markPos.y + CARET_VERTICAL_EXTEND},
				(Vector2){markPos.x, markPos.y + fontYSpacing - CARET_VERTICAL_EXTEND},
				1, COLOR_CARET_DIM);
		}

		/* Caret */
		Vector2 caretBoxPos = (Vector2){ (pCode->pCarets[0].col * fontXSpacing), ((pCode->pCarets[0].row - pCode->focusStartRow) * fontYSpacing) };
		Vector2 caretPos    = GetBoxLocalToWorld(caretBoxPos, codeRect);
		{
			DrawLineEx(
				(Vector2){caretPos.x, caretPos.y - CARET_VERTICAL_EXTEND},
				(Vector2){caretPos.x, caretPos.y + fontYSpacing + CARET_VERTICAL_EXTEND},
				2, COLOR_CARET);
		}

		/* Status Line  */
		{
			#define STATUS_TEXT_CAPACITY 1024
			static char statusText[STATUS_TEXT_CAPACITY];
			snprintf(statusText, STATUS_TEXT_CAPACITY, "caret0: index:%-4i icol:%-4i irow:%-4i lrow:%-4i rrow:%-4i token: %s %s start: %d end: %d brace: %d bracket: %d paren: %d\n",
				mainCaret.index, mainCaret.col, mainCaret.row, caretRow.startIndex, caretRow.endIndex, string_TOK(caretMeta.tok.val), string_TOK_KIND(caretMeta.tok.kind), caretMeta.tokOffset.iStart, caretMeta.tokOffset.iEnd, caretMeta.braceLevel, caretMeta.bracketLevel, caretMeta.parenLevel),
			DrawTextEx(rayde.font, statusText, (Vector2){ statusMarginRect.x, statusMarginRect.y }, fontSize, 0, COLOR_COMMENT);
		}

		/* Scan Highlight */
		if (command.enabled && command.scanFoundIndex > 0) {
			DrawRectangleRec((Rectangle){
					.x = scanFoundPosition.x,
					.y = scanFoundPosition.y,
					.width = fontXSpacing * command.bufferCount,
					.height = fontYSpacing},
				FIND_COLOR_COLOR);
			DrawLineEx(
				(Vector2){scanFoundPosition.x, scanFoundPosition.y},
				(Vector2){scanFoundPosition.x, scanFoundPosition.y + fontYSpacing},
				4, FIND_CARET_COLOR);
		}

		/* Command Box */
		if (command.enabled) {
			const int commandBoxExpand = 4;
			Rectangle commandBoxRect = {
				.x = caretPos.x - commandBoxExpand,
				.y = caretPos.y - commandBoxExpand,
				.width = fontXSpacing * command.bufferCount + commandBoxExpand * 2,
				.height = fontYSpacing + commandBoxExpand * 2,
			};

			DrawRectangleRec(commandBoxRect, COLOR_COMMAND_BOX);
			DrawRectangleLinesEx(commandBoxRect, 2, WHITE);

			for (int iCommand = 0; iCommand < command.bufferCount; ++iCommand) {
				char c = command.buffer[iCommand];
				int codePointSize;
				int codePoint = GetCodepoint(&c, &codePointSize);
				Vector2 charPos = { caretPos.x + (fontXSpacing * iCommand), caretPos.y };
				DrawTextCodepoint(rayde.font, codePoint, charPos, fontSize, WHITE);
			}
		}
	}
	EndDrawing();

	if(!WindowShouldClose())
		goto LoopBegin;

	/*
	 * Cleanup
	 */
	CloseWindow();

	return 0;
}
